# Алгоритмизация
## 1. Дайте определение массиву. Как осуществляется индексация элементов массива. Как необходимо обращаться к i-му элементу массива?
Массив — это структура данных, в которой хранятся элементы одного типа. Его можно представить, как набор пронумерованных ячеек, в каждую из которых можно поместить какие-то данные (один элемент данных в одну ячейку).
Доступ к конкретной ячейке осуществляется через её номер. Номер элемента в массиве также называют индексом.

Объявление массива, Java-синтаксис: `dataType[] arrayName;`

где:
dataType — тип переменных в массиве;
arrayName — это имя массива.

Пример:
```java
int[] myArray;
```
Как и любой другой объект, создать массив Java, то есть зарезервировать под него место в памяти, можно с помощью оператора new.

Делается это так:

```java
new typeOfArray [length];
```
где:
typeOfArray — это тип массива;
length — его длина (то есть, количество ячеек), выраженная в целых числах (int);

Обычно массив сначала объявляют, а потом создают, например:
```java
int[] myArray; // объявление массива
myArray = new int[10]; // создание, то есть, выделение памяти для массива на 10 элементов типа int
```
Однако гораздо чаще массив создают сразу после объявления с помощью такого сокращённого синтаксиса:
```java
int[] myArray = new int[10]; // объявление и выделение памяти “в одном флаконе”
```
Для численных типов (как в нашем примере) это будет 0, для boolean — false, для ссылочных типов — null.

Мы получаем массив из десяти целых чисел, и, пока это не изменится в ходе программы, в каждой ячейке записан 0.
Длина массива — это количество элементов, под которое рассчитан массив. Длину массива нельзя изменить после его создания.
В Java элементы массива нумеруются с нуля. То есть, если у нас есть массив на 10 элементов, то первый элемент массива будет иметь индекс 0, а последний — 9.
Получить доступ к длине массива можно с помощью переменной length.

Пример:
```java
int[] myArray = new int[10]; // создали массив целых чисел на 10 элементов и присвоили ему имя myArray
System.out.println(myArray.length); // вывели в консоль длину массива, то есть количество элементов
```
Получаем доступ к элементу массива (то есть записываем в него значение или выводим его на экран или проделываем с ним какую-либо операцию) мы по его индексу. Инициализация массива — это заполнение его конкретными данными (не по умолчанию).

Пример: создадим массив из 4 целых чисел
```java
int [] numbers  = new int[4]; 
/* объявили и создали массив. Java выделила память под массив из 
4 целых чисел, и сейчас в каждой ячейке записано значение 0 */

numbers[0] = 1; /* в первую ячейку, то есть, в ячейку с нулевым номером 
мы записали число 1. Тут мы получаем доступ к нулевому элементу массива 
и записываем туда конкретное значение  */
numbers[1] = "2"; // проделываем ту же процедуру с ячейкой номер 1 (второй)
numbers[2] = "3"; // ...номер 2
numbers[3] = "4"; // и с последней, номер 3

можно записать так:
int[] numbers  = new int[] {1, 2, 3, 4};
int[] numbers = {1,2,3,4}; // или так new можно опустить
```

## 2. Приведите способы объявления и инициализации одномерных и двумерных массивов примитивных и ссылочных типов. Укажите разницу, между массивами примитивных и ссылочных типов.
Так называемый одномерный массив:
```java
int[] myArray = new int[8];
```
А массив массивов называется двумерным. Он похож на таблицу, у которой есть номер строки и номер столбца. Или, если вы учили начала линейной алгебры, — на матрицу.
Такие массивы нужны, для программирования тех же матриц и таблиц, а также объектов, напоминающих их по структуре. Например, игровое поле для шахмат можно задать массивом 8х8.

Многомерный массив объявляется и создается следующим образом:
```java
int[][] myTwoDimentionalArray = new int[8][8];
```
В этом массиве ровно 64 элемента: myTwoDimentionalArray[0][0], myTwoDimentionalArray[0][1], myTwoDimentionalArray[1][0], myTwoDimentionalArray[1][1] и так далее вплоть до myTwoDimentionalArray[7][7].
Где два, там и три. В Java можно задать массив массивов… массив массивов массивов и так далее. Правда, трёхмерные и более массивы используются очень редко. Тем не менее, с помощью трёхмерного массива можно запрограммировать, например, кубик Рубика.
Разница, между массивами примитивных и ссылочных типов:
Основное отличие состоит в том, что примитивные переменные хранят фактические значения, в то время как ссылочные переменные хранят адреса объекты, на которые они ссылаются.

## 3. Объясните, что значит клонирование массива, как в Java можно клонировать массив, в чем состоит разница в клонировании массивов примитивных и ссылочных типов.
Точной копией оригинала является его клон. В Java это означает возможность создавать объект с аналогичной структурой, как и у исходного объекта. Метод clone() обеспечивает эту функциональность.
Поверхностное копирование копирует настолько малую часть информации, насколько это возможно. По умолчанию, клонирование в Java является поверхностным, т.е. Object class не знает о структуре класса, которого он копирует. При клонировании, JVM делает такие вещи:
1.	Если класс имеет только члены примитивных типов, то будет создана совершенно новая копия объекта и возвращена ссылка на этот объект.
2.	Если класс содержит не только члены примитивных типов, а и любого другого типа класса, тогда копируются ссылки на объекты этих классов. Следовательно, оба объекта будут иметь одинаковые ссылки.

Глубокое копирование дублирует все. Глубокое копирование — это две коллекции, в одну из которых дублируются все элементы оригинальной коллекции. Мы хотим сделать копию, при которой внесение изменений в любой элемент копии не затронет оригинальную коллекцию.

Глубокое клонирование требует выполнения следующих правил:
1. Нет необходимости копировать отдельно примитивные данные;
2. Все классы-члены в оригинальном классе должны поддерживать клонирование. Для каждого члена класса должен вызываться super.clone() при переопределении метода clone();
3. Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.

## 4. Объясните, что представляет собой двумерных массив в Java, что такое “рваный массив”. Как узнать количество строк и количество элементов в каждой строке для “рваного” массива?
Двумерный массив в Java — это массив массивов, то есть в каждой его ячейке находится ссылка на некий массив. Но гораздо проще его представить в виде таблицы, у которой задано количество строк (первое измерение) и количество столбцов (второе измерение). Двумерный массив, у которого все строки имеют равное количество элементов, называется прямоугольным.
Чтобы получить длину одномерного массива (то есть, количество элементов в нём), можно использовать переменную length. То есть, если мы определим массив int a[] = {1,2,3}, то операция a.length возвращает 3.
```java
int [][] twoDimArray = {{5,7,3,17}, {7,0,1,12}, {8,1,2,3}};
System.out.println(twoDimArray.length);
```
Таким образом, эта операция выводит количество строк в массиве. А как получить количество столбцов? Если мы имеем дело с прямоугольными двумерными массивами (то есть такими, у которых все строки одинаковой длины), то можно применить операцию twoDimArray[0].length или вместо нулевого элемента (по сути — нулевой строки) — любой другой существующий. Мы можем так поступить, потому что в Java двумерный массив — это массив массивов, и нулевой элемент twoDimArray[0] — это массив длины 4. Можете проверить это самостоятельно.
Зазубренный или также называемый рваный массив представляет собой n-мерный массив, который нужно не быть reactangular означает:
```java
int [][] twoDimArray = {{5,7,3,}, {7,0,1,12}, {8,1}};
System.out.println(twoDimArray.length);
```
Размер двумерного массива измеряется интересным способом. Длина массива определяется по его первой размерности, то есть вычисляется количество рядов.
```java
int[][] matrix = new int[4][5];
System.out.println(matrix.length);
```
Если мы хотим узнать количество столбцов в ряду. Необходимо указать ряд, а затем вычисляете у него количество столбцов.
```java
// число колонок у третьего ряда
System.out.println(matrix[2].length);
```
Не забывать, что в массивах ряды могут содержать разное количество столбцов.


## 5. Объясните ситуации, когда в java-коде могут возникнуть следующие исключительные ситуации java.lang.ArrayIndexOutOfBoundsException и java.lang.ArrayStoreException.
Исключение ArrayIndexOutOfBoundsException
Это исключение возникает, когда программа пытается адресовать элементы за пределами массива.
Исключение ArrayStoreException
Если попытаться записать в ячейку массива ссылку на объект неправильного типа, возникнет исключение ArrayStoreException.

## 6. Объясните, зачем при кодировании разделять решаемую задачу на методы. Поясните, как вы понимаете выражение: “Один метод не должен выполнять две задачи”.

Метод — это совокупность команд, позволяющая выполнить некоторую операцию в программе.
Для того, что каждый метод выполняет определенную задачу. Если в одном методе писать весь код, это приведет:
- Код будет не читаемый;
- Сложно будет найти баги;
- Код будет усложняться.

## 7. Объясните, как в Java передаются параметры в методы, в чем особенность передачи в метод значения примитивного типа, а в чем ссылочного.
Передача примитивов в методы в качестве параметров происходит по значению, а объектов – по ссылке
Иными словами для каждого параметра метода создается своя локальная копия. Следовательно, в Java методах все аргументы передаются по значению. В случае, когда аргумент – примитивный тип, передача по значению означает то, что метод не может изменить оригинальное значение. Когда же аргумент – ссылка на объект, создается локальная копия ссылки, которая указывает на тот же самый объект, при изменении которой оригинальное состояние объекта остается неизменным. (прим. редактора: верно - ВСЕ ПАРАМЕТРЫ В JAVA ПЕРЕДАЮТСЯ ПО ЗНАЧЕНИЮ. Если параметр — ссылка на объект, то ЗНАЧЕНИЕМ является ЗНАЧЕНИЕ самой ссылки, а не значение разнообразных полей в объекте, коих может быть великое множество, как по количеству, так и по разнообразию типов).

## 8. Объясните, как в метод передать массив. И как массив вернуть из метода. Можно ли в методе изменить размер переданного массива.
Я беру с базы данных сайта ники пользователей с определенным значением и заменяю значение, чтобы больше не брать этиже ники. Вношу их в массив и передаю его через return основному классу. А после передачи мне нужно вернуть массив, чтобы в следующий раз снова не передать этиже ники.
```java
public class sql {
    public static void main(String[] args) {

        String[] name = new String[]{"caf", "caf1", "caf2", "caf3"};
        String[] name_return = name;
        for (int i = 0; i < name.length; i++) {
            name[i] = null;
        }
        return name_return;
    }
}
```
В методе можно изменить размер переданного массива.

## 9. Поясните, что означает выражение ‘вернуть значение из метода’. Как можно вернуть значение из метода. Есть ли разница при возврате значений примитивного и ссылочного типов.

Вернуть значение из метода – это означает прийти в начало метода. Пример возвращения написан в вопросе 9.

## 10. Перечислите известные вам алгоритмы сортировки значений, приведите код, реализующий это алгоритмы.

###  Простейшая сортировка (Bubble Sort)
Отсортировать по возрастанию. Это значит, что имея два элемента (например, a=6, b=5), мы должны переставить местами a и b, если a больше чем b (если a > b).
Что для нас это значит при работе с коллекцией по индексу (как в случае с массивом)? Это значит, что если элемент с индексом а больше, чем элемент с индексом b, (array[a] > array[b]), такие элементы надо поменять местами.
Перемену мест часто называют swap.

Пример:
```java
int[] array = {10, 2, 10, 3, 1, 2, 5};
System.out.println(Arrays.toString(array));
boolean needIteration = true;
while (needIteration) {
	needIteration = false;
	for (int i = 1; i < array.length; i++) {
		if (array[i] < array[i - 1]) {
			swap(array, i, i-1);
			needIteration = true;
		}
	}
}
System.out.println(Arrays.toString(array));
```

Вот наша первая сортировка и отработала. Мы итерируемся во внешнем цикле (while) до тех пор, пока не решим, что итераций больше не нужно. По умолчанию перед каждой новой итерацией мы допускаем, что наш массив отсортирован, и больше итерироваться не хотим. Поэтому, мы проходим элементы последовательно и проверяем это допущение. Но если элементы не по порядку, мы выполняем swap элементов и понимаем, что нет уверенности, что теперь элементы в правильном порядке. Следовательно, хотим выполнить ещё одну итерацию. Например, [3, 5, 2]. 5 больше трёх, всё хорошо. Но 2 меньше 5. Однако [3, 2, 5] требует ещё одного прохода, т.к. 3 > 2 и их нужно поменять местами. Так как мы используем цикл в цикле, получается, что сложность нашего алгоритма увеличивается. При n элементах она становится n * n, то есть O(n^2). Такая сложность называется квадратичной. Как мы понимаем, мы не можем точно знать, сколько понадобится итераций. Показатель сложности алгоритма служит цели показать тенденцию роста сложности, худший случай. Насколько сильно будет увеличиваться время работы при изменении количества элементов n.
Сортировка пузырьком — одна из самых простых и неэффективных сортировок. Её ещё иногда называют "глупой сортировкой".

### Сортировка выбором (Selection Sort)

Другая сортировка — сортировка выбором. Она также имеет квадратичную сложность, но об этом чуть позже. Итак, идея простая. Каждый проход выбирать самый минимальный элемент и смещать его в начало. При этом каждый новый проход начинать сдвигаясь вправо, то есть первый проход — с первого элемента, второй проход — со второго. Выглядеть это будет следующим образом:
```java
int[] array = {10, 2, 10, 3, 1, 2, 5};
System.out.println(Arrays.toString(array));
for (int left = 0; left < array.length; left++) {
	int minInd = left;
	for (int i = left; i < array.length; i++) {
		if (array[i] < array[minInd]) {
			minInd = i;
		}
	}
	swap(array, left, minInd);
}
System.out.println(Arrays.toString(array));
```
Данная сортировка неустойчива, т.к. одинаковые элементы (с точки зрения той характеристики, по которой мы сортируем элементы) могут изменить своё положение.

### Сортировка вставками (Insertion Sort)

Сортировка вставками тоже имеет квадратичную сложность, так как у нас опять цикл в цикле. В чём отличие от сортировки выбором? Данная сортировка является "устойчивой". Это значит, что одинаковые элементы не изменят свой порядок. Одинаковые с точки зрения характеристики, по которой мы сортируем.
```java
int[] array = {10, 2, 10, 3, 1, 2, 5};
System.out.println(Arrays.toString(array));
for (int left = 0; left < array.length; left++) {
	// Вытаскиваем значение элемента
	int value = array[left];
	// Перемещаемся по элементам, которые перед вытащенным элементом
	int i = left - 1;
	for (; i >= 0; i--) {
		// Если вытащили значение меньшее — передвигаем больший элемент дальше
		if (value < array[i]) {
			array[i + 1] = array[i];
		} else {
			// Если вытащенный элемент больше — останавливаемся
			break;
		}
	}
	// В освободившееся место вставляем вытащенное значение
	array[i + 1] = value;
}
System.out.println(Arrays.toString(array));
```

### Челночная сортировка (Shuttle Sort)
Среди простых сортировок есть ещё одна — челночная сортировка. Но мне больше нравится шаттл сорт. Мне кажется, мы редко говорим про космические челноки, а челночный у нас скорее бег. Поэтому проще представить, как в космос запускаются шаттлы. Вот вам ассоциация с этим алгоритмом. В чём суть алгоритма? Суть алгоритма в том, что мы итерируемся слева направо, при этом при выполнении swap элементов мы выполняем проверку всех остальных элементов, которые остались позади, не нужно ли повторить swap.
```java
int[] array = {10, 2, 10, 3, 1, 2, 5};
System.out.println(Arrays.toString(array));
for (int i = 1; i < array.length; i++) {
	if (array[i] < array[i - 1]) {
		swap(array, i, i - 1);
		for (int z = i - 1; (z - 1) >= 0; z--) {
			if (array[z] < array[z - 1]) {
				swap(array, z, z - 1);
			} else {
				break;
			}
		}
	}
}
System.out.println(Arrays.toString(array));
```

### Сортировка Шелла
Ещё одной простой сортировкой является сортировка Шелла. Суть её похожа на сортировку пузырьком, но каждую итерацию мы имеем разный промежуток между сравниваемыми элементами. Каждую итерацию он уменьшается вдвое. Вот пример реализации:
```java
int[] array = {10, 2, 10, 3, 1, 2, 5};
System.out.println(Arrays.toString(array));
// Высчитываем промежуток между проверяемыми элементами
int gap = array.length / 2;
// Пока разница между элементами есть
while (gap >= 1) {
    for (int right = 0; right < array.length; right++) {
        // Смещаем правый указатель, пока не сможем найти такой, что
        // между ним и элементом до него не будет нужного промежутка
       for (int c = right - gap; c >= 0; c -= gap) {
           if (array[c] > array[c + gap]) {
               swap(array, c, c + gap);
           }
        }
    }
    // Пересчитываем разрыв
    gap = gap / 2;
}
System.out.println(Arrays.toString(array));
```

### Cортировка слиянием (merge sort)

Помимо указанных простых сортировок, есть сортировки и посложнее. Например, сортировка слиянием. Во-первых, нам на помощь придёт рекурсия. Во-вторых, сложность у нас будет уже не квадратичная, как мы с вами привыкли. Сложность данного алгоритма — логарифмическая. Записывается как O(n log n).
```java
public static void mergeSort(int[] source, int left, int right) {
        // Выберем разделитель, т.е. разделим пополам входной массив
        int delimiter = left + ((right - left) / 2) + 1;
        // Выполним рекурсивно данную функцию для двух половинок (если сможем разбить(
        if (delimiter > 0 && right > (left + 1)) {
            mergeSort(source, left, delimiter - 1);
            mergeSort(source, delimiter, right);
        }
}
public static void mergeSort(int[] source, int left, int right) {
        // Выберем разделитель, т.е. разделим пополам входной массив
        int delimiter = left + ((right - left) / 2) + 1;
        // Выполним рекурсивно данную функцию для двух половинок (если сможем разбить(
        if (delimiter > 0 && right > (left + 1)) {
            mergeSort(source, left, delimiter - 1);
            mergeSort(source, delimiter, right);
        }
        // Создаём временный массив с нужным размером
        int[] buffer = new int[right - left + 1];
        // Начиная от указанной левой границы идём по каждому элементу
        int cursor = left;
        for (int i = 0; i < buffer.length; i++) {
            // Мы используем delimeter чтобы указывать на элемент из правой части
            // Если delimeter > right, значит в правой части не осталось недобавленных элементов
            if (delimiter > right || source[cursor] > source[delimiter]) {
                buffer[i] = source[cursor];
                cursor++;
            } else {
                buffer[i] = source[delimiter];
                delimiter++;
            }
        }
        System.arraycopy(buffer, 0, source, left, buffer.length);
}
```
Запустим пример при помощи вызова метода mergeSort(array, 0, array.length-1). Как видно, суть сводится к тому, что мы принимаем на вход массив с указанием начала и конца участка для сортировки. При начале сортировки — это начало и конец массива. Далее мы вычисляем delimiter — положение делителя. Если делитель может разделить на 2 части, значит вызываем рекурсивно сортировку для участков, на которые делитель разбил массив. Подготавливаем дополнительный буферный массив, в котором выделяем отсортированный участок. Далее устанавливаем курсор в начало сортируемого участка и начинаем идти по каждому элементу пустого массива, который мы подготовили, и заполняем его наименьшими элементами. Если элемент, на который указывает курсор меньше, чем элемент, на который указывает делитель — помещаем в буферный массив этот элемент и сдвигаем курсор. В противном случае помещаем в буферный массив элемент, на который указывает разделитель и сдвигаем разделитель. Как только разделитель уйдёт за границы сортируемого участка или мы заполним весь массив, указанный диапазон считается отсортированным.

### Сортировка подсчётом (Counting Sort) и Поразрядная сортировка (Radix Sort)
Другим интересным алгоритмом сортировки является сортировка подсчётом (Counting Sort). Алгоритмическая сложность в этом случае будет O(n+k), где n — количество элементов, а k — максимальное значение элемента. Есть с алгоритмом одна незадача: нам нужно знать минимальное и максимальное значение в массиве. Вот пример реализации сортировки подсчётом:
```java
public static int[] countingSort(int[] theArray, int maxValue) {
    // Массив со "счётчиками" размером от 0 до максимального значения
    int numCounts[] = new int[maxValue + 1];
    // В соответствующей ячейке (индекс = значение) увеличиваем счётчик
    for (int num : theArray) {
        numCounts[num]++;
    }
    // Подготавливаем массив для отсортированного результата
    int[] sortedArray = new int[theArray.length];
    int currentSortedIndex = 0;
    // идём по массиву со "счётчиками"
    for (int n = 0; n < numCounts.length; n++) {
        int count = numCounts[n];
        // идём по количеству значений
        for (int k = 0; k < count; k++) {
            sortedArray[currentSortedIndex] = n;
            currentSortedIndex++;
        }
    }
    return sortedArray;
}
```

### Быстрая сортировка (Quick Sort)
Ну и на сладкое — один из самых известных алгоритмов: быстрая сортировка. Она имеет алгоритмическую сложность, то есть мы имеем O(n log n). Данную сортировку ещё называют сортировкой Хоара.
```java
public static void quickSort(int[] source, int leftBorder, int rightBorder) {
        int leftMarker = leftBorder;
        int rightMarker = rightBorder;
        int pivot = source[(leftMarker + rightMarker) / 2];
        do {
            // Двигаем левый маркер слева направо пока элемент меньше, чем pivot
            while (source[leftMarker] < pivot) {
                leftMarker++;
            }
            // Двигаем правый маркер, пока элемент больше, чем pivot
            while (source[rightMarker] > pivot) {
                rightMarker--;
            }
            // Проверим, не нужно обменять местами элементы, на которые указывают маркеры
            if (leftMarker <= rightMarker) {
                // Левый маркер будет меньше правого только если мы должны выполнить swap
                if (leftMarker < rightMarker) {
                    int tmp = source[leftMarker];
                    source[leftMarker] = source[rightMarker];
                    source[rightMarker] = tmp;
                }
                // Сдвигаем маркеры, чтобы получить новые границы
                leftMarker++;
                rightMarker--;
            }
        } while (leftMarker <= rightMarker);

        // Выполняем рекурсивно для частей
        if (leftMarker < rightBorder) {
            quickSort(source, leftMarker, rightBorder);
        }
        if (leftBorder < rightMarker) {
            quickSort(source, leftBorder, rightMarker);
        }
}
```
Тут всё очень страшно, так что будем разбираться. Для входного массива int[] source выставляем два маркера, левый (L) и правый (R). При первом вызове они соответствуют началу и концу массива. Далее определяется опорный элемент, он же pivot. После этого наша задача — переместить значения, меньшие чем pivot, в левую от pivot часть, а большие — в правую. Для этого сначала двигаем указатель L, пока не найдём значение, большее чем pivot. Если меньше значения не нашли, то L совпадёт с pivot. Потом двигаем указатель R пока не найдём меньшее, чем pivot значение. Если меньшее значение не нашли, то R совпадёт с pivot. Далее, если указатель L находится до указателя R или совпадает с ним, то пытаемся выполнить обмен элементов, если элемент L меньше, чем R. Далее L сдвигаем вправо на 1 позицию, R сдвигаем влево на одну позицию. Когда левый маркер L окажется за правым маркером R это будет означать, что обмен закончен, слева от pivot меньшие значения, справа от pivot — большие значения. После этого рекурсивно вызываем такую же сортировку для участков массива от начала сортируемого участка до правого маркера и от левого маркера до конца сортируемого участка. Почему от начала до правого? Потому что в конце итерации так и получится, что правый маркер сдвинется настолько, что станет границей части слева. Этот алгоритм более сложный, чем простая сортировка, поэтому его лучше зарисовать. Возьмём белый лист бумаги, запишем: 4 2 6 7 3 , а Pivot по центру, т.е. число 6. Обведём его в круг. Под 4 напишем L, под 3 напишем R. 4 меньше чем 6, 2 меньше чем 6. Итого, L переместился на положение pivot, т.к. по условию L не может уйти дальше, чем pivot. Напишем снова 4 2 6 7 3 , обведём 6 вкруг (pivot) и поставим под ним L. Теперь двигаем указатель R. 3 меньше чем 6, поэтому ставим маркер R на цифру 3. Так как 3 меньше, чем pivot 6 выполняем swap, т.е. обмен. Запишем результат: 4 2 3 7 6 , обводим 6 вкруг, т.к. он по прежнему pivot. Указатель L на цифре 3, указатель R на цифре 6. Мы помним, что двигаем указатели до тех пор, пока L не зайдём за R. L двигаем на следующую цифру. Тут хочется разобрать два варианта: если бы предпоследняя цифра была 7 и если бы она была не 7, а 1. Предпоследня цифра 1: Сдвинули указатель L на цифру 1, т.к. мы можем двигать L до тех пор, пока указатель L указывает на цифру, меньшую чем pivot. А вот R мы не можем сдвинуть с 6, т.к. R не мы можем двигать только если указатель R указывает на цифру, которая больше чем pivot. swap не делаем, т.к. 1 меньше 6. Записываем положение: 4 2 3 1 6, обводим pivot 6. L сдвигается на pivot и больше не двигается. R тоже не двигается. Обмен не производим. Сдвигаем L и R на одну позицию и подписываем цифру 1 маркером R, а L получается вне числа. Т.к. L вне числа — ничего не делаем, а вот часть 4 2 3 1 выписываем снова, т.к. это наша левая часть, меньшая, чем pivot 6. Выделяем новый pivot и начинаем всё снова ) Предпоследняя цифра 7: Сдвинули указать L на цифру 7, правый указатель не можем двигать, т.к. он уже указывает на pivot. т.к. 7 больше, чем pivot, то делаем swap. Запишем результат: 4 2 3 6 7, обводим 6 кружком, т.к. он pivot. Указатель L теперь сдвигается на цифру 7, а указатель R сдвигается на цифру 3. Часть от L до конца нет смысла сортировать, т.к. там всего 1 элемент, а вот часть от 4 до указателя R отправляем на сортировку. Выбираем pivot и начинаем всё снова ) Может на первый взгляд показаться, что если расставить много одинаковых с pivot значений, это сломает алгоритм, но это не так. Можно напридумывать каверзных вариантов и на бумажке убедиться, что всё правильно и подивиться, как такие простые действия предоставляют такой надёжный механизм. Единственный минус — такая сортировка не является стабильной. Т.к. при выполнении обмена одинаковые элементы могут поменять свой порядок, если один из них встретился до pivot до того, как другой элемент попал в часть до pivot при помощи обмена.
