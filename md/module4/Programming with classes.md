#Programming with classes

##1.	Опишите процедуру инициализации полей класса и полей экземпляра класса. Когда инициализируются поля класса, а когда – поля экземпляров класса. Какие значения присваиваются полям по умолчанию? Где еще в классе полям могут быть присвоены начальные значения?

Java является Объекто-оирентированным (далее ОО) языком программирования. 

**Следовательно, в работе мы будем оперировать следующими понятиями:**

•	Класс
•	Объект
•	Экземпляр
•	Метод
•	Наследование
•	Полиморфизм
•	Инкапсуляция

**Класс**

Сущность, которая характеризуется полями (аттрибутами) и поведением (методами). Например, разработчик имеет имя, фамилию, специализацию, зарплату и т.д.
Объект

**Объект** – это экземпляр класса. Например, конкретный разработчик.

Имя: Иван
Фамилия: Иванов
Специализация: Java – разработчик
Зарплата: 100500 долларов в час

**Объекты**

Если посмотрим на реальный мир, то увидим, что нас окружают объекты – Люди, Звери, Птицы, Машины и .т.д. Всё это объекты, которые имеют свои свойства и поведение.
Например, человек имеет рост, вес, имя, цвет волос, увет глаз и так далее. Человек также имеет опредлеённое поведение. Он дышит, видит, слышит, говорит и т.д.
В программах различные объекты взаимодействуют друг с другом, используя своё поведение. Например, человек взаимодействует с миром (мир – это тоже объект) используя поведение видеть.

**Класс**

Класс сущность, экземпляром которой является объект. Например, объектом класса Человек будет конкретный человек – Иванов Иван Иванович. Другими словами, Иванов Иван Иванович – это объекта класса человек.

**Класс может включать в себя:**

•	локальные переменные – Это переменные, которые опредеяются внутри методов или конструкторов. Т.е. переменная объявляется внутри метода и уничтожается после того, как программа завершает выполнение метода.
•	переменные экземпляра –  Это переменные, которые объявляются внутри класса, но не внутри метода. Эти переменные инициализируются в момент создания экземлпляра класса (инициализации).
•	переменные класса – Это переменные, которые объявляются внутри класса, вне метода с помощью ключевого слова static.
Класс может иметь любое количество переменных и методов. Методы вглядят, примерно, так:
breath()
walk()
________________________________________
**Конструкторы**
Наиболее важной частью обсуждения классов являются конструкторы. Любой класс в Java имеет конструктор. Даже если мы не прописываем его, то компилятор Java сам создаёт для этого класса конструктор по умолчанию.
Каждый раз, когда мы создаём новый объект (экземпляр класса), запускается конструктор. Главное правило для конструкторов – они должны иметь такое же имя, как и сам класс.
Создание объекта
Если мы хотим создать объект (эзкмпляр класса), то мы должны создать класс, содержащтй метод main(), внтури которого и происходит выполнение программы.
Создание объекта состоит из трёх этапов:
Декларация
Декларирование переменной типа класса с уникальным именем.
Инстанциация
Создание нового объекта с использование ключевого слова ‘new’.
Инициализация
Вызов конструкторв, который идёт после ключевого слова ‘new’.

**Приведём простой пример:**

``` public class Person {
    private String name;
    /**
     * Default constructor
     */
    public Person() {
    }
    /**
     * Constructor that has parameter name
     */
    public Person(String name) {
        this.name = name;
    }
    public String toString() {
        return "\n========================\n" +
                "Person:\n" +
                "Name: " + name +
                "\n========================\n";
    }
}
```

Теперь создадим класс, который будет использовать наш класс Person.

```public class PersonRunner {
    public static void main(String[] args) {
        Person person = new Person("Ivan Ivanov");
        System.out.println(person);
    }
}
```
##2.	Дайте определение перегрузке методов. Как вы думаете, чем удобна перегрузка методов? Укажите, какие методы могут перегружаться, и какими методами они могут быть перегружены? Можно ли перегрузить методы в базовом и производном классах? Можно ли private метод базового класса перегрузить public методов производного? Можно ли перегрузить конструкторы, и можно ли при перегрузке конструкторов менять атрибуты доступа у конструкторов?

Java позволяет создавать несколько методов с одинаковыми именами, но разными сигнатурами. Создание метода с тем же именем, но с другим набором параметров называется перегрузкой. Какой из перегруженных методов должен выполняться при вызове, Java определяет на основе фактических параметров.

Перегрузка методов является одним из способов реализации принципа полиморфизма в Java.
Для того чтобы перегрузить метод, достаточно объявить его новый вариант, отлича¬ющийся от уже существующих, а все остальное сделает компилятор. Нужно лишь со¬блюсти одно условие: тип и/или число параметров в каждом из перегружаемых методов должны быть разными.
Одного лишь различия в типах возвращаемых значений для этой цели недостаточно. (Информации о возвращаемом типе не всегда будет хватать Java для принятия решения о том, какой именно метод должен использоваться.)

Конечно, пе¬регружаемые методы могут иметь разные возвращаемые типы, но при вызове метода выполняется лишь тот его вариант, в котором параметры соответствуют передаваемым аргументам.
Ниже приведен простой пример программы, демонстрирующий перегрузку методов.
```
class Overload {
     // Первая версия
    void ovlDemo() {
        System.out.println("Без параметров");
    }
     // Перезагрузка метода ovlDemo для одного параметра типа int
    // Вторая версия
    void ovlDemo(int a) {
        System.out.println("Один параметр: " + a);
    }
     // Перезагрузка метода ovlDemo для двух параметров типа int
    // Третья версия
    int ovlDemo(int a, int b) {
        System.out.println("Два параметра: " + a + " " + b);
        return a + b;
    }
     // Перезагрузка метода ovlDemo для двух параметров типа double
    // Четвертая версия
    double ovlDemo(double a, double b) {
        System.out.println("Два параметра типа double: " + a + " " + b);
        return a + b;
    }
 }
 
class OverloadDemo {
    public static void main(String args[]) {
        Overload ob = new Overload();
        int resI;
        double resD;
     // Поочередно вызвать все версии метода ovlDemo()
    ob.ovlDemo();
    System.out.println();
        ob.ovlDemo(2);
    System.out.println();
        resI = ob.ovlDemo(4, 6);
    System.out.println("Результат вызова ob.ovlDemo(4, 6): " + resI);
    System.out.println();
     resD = ob.ovlDemo(1.1, 2.32);
    System.out.println("Результат вызова ob.ovlDemo(1.1, 2.32): " + resD);
     }
 }
```
Как видите, метод ovlDemo() перегружается четырежды. В первой его версии па¬раметры не предусмотрены, во второй - определен один целочисленный параметр, в третьей - два целочисленных параметра, в четвертой - два параметра типа double.
Обратите внимание на то, что первые два варианта метода ovlDemo() имеют тип void, а два другие возвращают значение. Тип возвращаемого значения не учитывается при перегрузке методов. Следовательно, попытка определить два варианта метода ovlDemo() так, как показано ниже, приводит к ошибке.

Возвращаемое значение нельзя использовать
  для различения перезагружаемых методов
```*/
void ovlDemo(int a) {
    System.out.println("One parameter: " + a);
}
 ```
/* Ошибка! Невозможно существование двух версий
 перезагруженного метода ovlDemo(int), отличающихся
 лишь типом возвращаемого значения.
*/
 ```
int ovlDemo(int a) {
    System.out.println("Один параметр: " + a);
    return a * a * a;
}
```
Как поясняется в комментариях к приведенному выше фрагменту кода, отличия воз¬вращаемых типов недостаточно для перегрузки методов.
Как мы знаем, в Java применяется автоматическое приведение типов. Это приведение распространяется и на типы параметров перегружаемых методов. В качестве примера рассмотрим следующий фрагмент кода.

 Автоматическое преобразование типов
    может влиять на выбор перезагружаемого метода.
```*/
 
class Overload2 {
    void f(int x) {
        System.out.println("Внутри f(int): " + x);
    }
 
    void f(double x) {
        System.out.println("Внутри f(double): " + x);
    }
}
 
class TypeConv {
    public static void main(String args[]) {
 
        Overload2 ob = new Overload2();
        int i = 10;
        double d = 10.1;
        byte b = 99;
        short s = 10;
        float f = 11.5F;
 
        ob.f(i); // вызов метода ob.f(int)
        ob.f(d); // вызов метода ob.f(double)
        ob.f(b); // вызов метода ob.f(int) с преобразованием типов
        ob.f(s); // вызов метода ob.f(int) с преобразованием типов
        ob.f(f); // вызов метода ob.f(double) с преобразованием типов
     }
}
```
В данном примере определены только два варианта метода f(): один принимает параметр типа int, а второй - параметр типа double.
Но передать методу f() можно также значение типа byte, short и float. Значения типа byte и short исполняющая система Java автоматически преобразует в тип int. В результате будет вызван вариант метода f(int). А если параметр имеет значение типа float, то оно преобразуется в тип doube, и далее вызывается вариант метода f(double).
Важно понимать, что автоматическое преобразование типов выполняется лишь в от¬сутствие прямого соответствия типов параметра и аргумента. В качестве примера ниже представлена другая версия предыдущей программы, в которой добавлен вариант метода f() с параметром типа byte.
```
class Overload3 {
    void f(byte x) {
        System.out.println("Внутри f(byte): " + x);
    }
     void f(int x) {
        System.out.println("Внутри f(int): " + x);
    }
     void f(double x) {
        System.out.println("Внутри f(double): " + x);
    }
 }
    
 class TypeConv {
    public static void main(String args[]) {
 
        Overload3 ob = new Overload3();
        int i = 10;
        double d = 10.1;
        byte b = 99;
        short s = 10;
        float f = 11.5F;
 
        ob.f(i); // вызов метода ob.f(int)
        ob.f(d); // вызов метода ob.f(double)
        ob.f(b); // вызов метода ob.f(byte) без преобразования типов
        ob.f(s); // вызов метода ob.f(int) с преобразованием типов
        ob.f(f); // вызов метода ob.f(double) с преобразованием типов
 
    }
}
```
Поскольку в данной программе предусмотрена версия метода f(), которая принима¬ет параметр типа byte, то при вызове этого метода с аргументом типа byte выполняется вызов f (byte), и автоматического преобразования типа byte в тип int не происходит.

Перегрузка методов поддерживает полиморфизм, поскольку она является одним из способов реализации парадигмы "один интерфейс - множество методов". Для того чтобы стало понятнее, как и для чего это делается, необходимо принять во внимание следующее соображение: в языках программирования, не поддерживающих перегрузку методов, каждый метод должен иметь уникальное имя.

Но в ряде случаев требуется вы¬полнять одну и ту же последовательность операций над разными типами данных. В качестве примера рассмотрим функцию, определяющую абсолютное значение.
В языках, не поддерживающих перегрузку методов, приходится создавать несколько вариантов данной функции с именами, отличающимися хотя бы одним символом.
Например,в языке С функция abs() возвращает абсолютное значение числа типа int, функция labs() - абсолютное значение числа типа long, а функция fabs() - абсолютное зна¬чение числа с плавающей точкой.

Объясняется это тем, что в С не поддерживается пе¬регрузка, и поэтому каждая из функций должна обладать своим собственным именем,несмотря на то что все они выполняют одинаковые действия. Это приводит к нео¬правданному усложнению процесса написания программ.
Разработчику приходится не только представлять себе действия, выполняемые функциями, но и помнить все три их имени. Такая ситуация не возникает в Java, потому что все методы, вычисляющие абсо¬лютное значение, имеют одно и то же имя.
В стандартной библиотеке Java для вычисле¬ния абсолютного значения предусмотрен метод abs(). Его перегрузка осуществляется в классе Math для обработки значений всех числовых типов.
Решение о том, какой имен¬но вариант метода abs() должен быть вызван, исполняющая система Java принимает, исходя из типа аргумента.
Главная ценность перегрузки заключается в том, что она обеспечивает доступ к груп¬пе родственных методов по общему имени. Следовательно, имя abs обозначает общее выполняемое действие, а компилятор сам выбирает конкретный вариант метода по об¬стоятельствам.
Благодаря полиморфизму несколько имен сводятся к одному. Несмотря на всю простоту рассматриваемого здесь примера, продемонстрированный в нем прин¬цип полиморфизма можно расширить, чтобы выяснить, каким образом перегрузка по¬могает справляться с более сложными ситуациями в программировании.

Когда метод перегружается, каждая его версия может выполнять какое угодно дей¬ствие. Для установления взаимосвязи перегружаемых методов не существует какого-то твердого правила, но с точки зрения правильного стиля программирования перегрузка методов подразумевает подобную взаимосвязь. Следовательно, использовать одно и тоже имя для несвязанных друг с другом методов не следует, хотя это и возможно.

Напри¬мер, имя sqr можно было бы выбрать для методов, возвращающих квадрат и квадрат¬ный корень числа с плавающей точкой. Но ведь это принципиально разные операции.
Такое применение перегрузки методов противоречит ее первоначальному назначению.На практике перегружать следует только тесно связанные операции.

Стоит отметить, что, программисты на Java часто употребляют термин сигнатура. Что это такое?
Применительно к языку Java сигнатура обозначает имя метода и список его пара¬метров. При перегрузке методов действует следующее правило: никакие два ме¬тода из одного класса не могут иметь одинаковые сигнатуры.

Следует, однако, иметь в виду, что сигнатура не включает в себя тип возвращаемого значения, поскольку он не используется в Java при принятии решения о перегрузке.
Статические методы могут перегружаться нестатическими и наоборот – без ограничений
Переопределять можно любые видимые в производном классе не финальные методы. Исключение - переопределение конструкторов базового класс невозможно! 

В производном классе разрешается перегружать (overload) любые видимые методы. При наследовании, Вы берете существующий класс и создаете специальную его версию.
**Конструктор** – это схожая c методом структура, назначение которой состоит в создании экземпляра класса. 

**Характеристики конструктора:**
Имя конструктора должно совпадать с именем класса (по договоренности, первая буква — заглавная, обычно имя существительное);

Конструктор имеется в любом классе. Даже если вы его не написали, компилятор Java сам создаст конструктор по умолчанию (default constructor), который будет пустым и не делает ничего, кроме вызова конструктора суперкласса.

Конструктор похож на метод, но не является методом, он даже не считается членом класса. Поэтому его нельзя наследовать или переопределить в подклассе;

Конструкторы не наследуются;

Конструкторов может быть несколько в классе. В этом случае конструкторы называют перегруженными;

Если в классе не описан конструктор, компилятор автоматически добавляет в код конструктор без параметров;

Конструктор не имеет возвращаемого типа, им не может быть даже тип void, если возвращается тип void, то это уже не конструктор а метод, несмотря на совпадение с именем класса.

В конструкторе допускается оператор return, но только пустой, без всякого возвращаемого значения;

В конструкторе допускается применение модификаторов доступа, можно задать один из модификаторов: public, protected, private или без модификатора.

Конструктор не может иметь модификаторов abstract, final, native, static или synchronized;

Ключевое слово this cсылается на другой конструктор в этом же классе. Если используется, то обращение должно к нему быть первой строкой конструктора;

Ключевое слово super вызывает конструктор родительского класса. Если используется, должно обращение к нему быть первой строкой конструктора;

Если конструктор не делает вызов конструктора super класса-предка (с аргументами или без аргументов), компилятор автоматически добавляет код вызова конструктора класса-предка без аргументов;

**Конструктор по умолчанию**
Конструктор имеется в любом классе. Даже если вы его не написали, компилятор Java сам создаст конструктор по умолчанию (default constructor). Этот конструктор пустой и не делает ничего, кроме вызова конструктора суперкласса. 
Конструкторы одного класса могут иметь одинаковое имя и различную сигнатуру. Такое свойство называется совмещением или перегрузкой(overloading). Если класс имеет несколько конструкторов, то присутствует перегрузка конструкторов.

##3.	Объясните, что такое раннее и позднее связывание? Перегрузка – это раннее или позднее связывание? Объясните правила, которым следует компилятор при разрешении перегрузки; в том числе, если методы перегружаются примитивными типами, между которыми возможно неявное приведение или ссылочными типами, состоящими в иерархической связи.

Чтобы выяснить, в чем состоит различие между ранним (статическим) и поздним (динамическим) связыванием в Java, нужно сначала понять, что такое это самое связывание. Связывание означает наличие связи между ссылкой и кодом. Например, переменная, на которую вы ссылаетесь, привязана к коду, в котором она определена. Аналогично, вызываемый метод привязан к месту в коде, где он определен. 

Существует два типа связывания методов в языке Java: ранее связывание (его ещё называют статическим) и позднее (соответственно, динамическое) связывание. Вызов метода в Java означает, что этот метод привязывается к конкретному коду или в момент компиляции, или во время выполнения, при запуске программы и создании объектов. Можно понять из названия, статическое связывание носит более статический характер, так как происходит во время компиляции, то есть код «знает», какой метод вызывать после компиляции исходного кода на Java в файлы классов. А поскольку это относится к ранней стадии жизненного цикла программы, то называется также ранним связыванием (early binding). С другой стороны, динамическое связывание происходит во время выполнения, после запуска программы виртуальной машиной Java. В этом случае то, какой метод вызвать, определяется конкретным объектом, так что в момент компиляции информация недоступна, ведь объекты создаются во время выполнения. А поскольку это происходит на поздней стадии жизненного цикла программы, то называется в языке Java поздним связыванием (late binding).

Итак, фундаментальное различие между статическим и динамическим связыванием в Java состоит в том, что первое происходит рано, во время компиляции на основе типа ссылочной переменной, а второе – позднее, во время выполнения, с использованием конкретных объектов.
Существует множество различий статического и динамического связывания в языке Java, но важнейшее – то, как их использует JVM. Задумывались ли вы когда-нибудь, каким образом JVM решает, какой метод вызвать, если в области видимости содержится более одного метода с одним именем? Если вы когда-либо использовали перегрузку или переопределение методов, то знаете, что в Java может быть несколько методов с одним именем. В случае с Java виртуальная машина JVM использует как статическое, так и динамическое связывание для выбора нужного метода.
Пример статического и динамического связывания в Java

В этой программе вы увидите, что привязка виртуальных методов не происходит во время компиляции при помощи статического связывания, поскольку в этом случае вызывался бы метод из суперкласса, как происходит со статическими методами, которые связываются рано. Если будет вызван метод из подкласса, то для связывания функции использовался конкретный объект во время выполнения, а, следовательно, для связывания виртуальных функций используется динамическое связывание.
```
public class Main {
  public static void main(String[] args) {
    // Пример статического и динамического связывания в Java
    Insurance current = new CarInsurance();
    // Динамическое связывание на основе объекта
    int premium = current.premium();
    // Статическое связывание на основе класса
    String category = current.category();

    System.out.println("premium : " + premium);
    System.out.println("category : " + category);
  }
}
class Insurance{
  public static final int LOW = 100;
  public int premium(){
    return LOW;
  }
  public static String category(){
    return "Insurance";
  }
}
class CarInsurance extends Insurance{
  public static final int HIGH = 200;
  public int premium(){
    return HIGH;
  }
  public static String category(){
    return "Car Insurance";
  }
}
Результаты выполнения:
premium : 200
category : Insurance
```
Как вы видите, вызов метода premium() привел к выполнению метода из подкласса, в то время как вызов метода category() привел к выполнению метода суперкласса. Это происходит из-за того, что premium() – виртуальный метод, который разрешается при помощи позднего связывания, в то время как category() – статический метод, который разрешается при помощи статического связывания во время компиляции по имени класса.


##4.	Объясните, как вы понимаете, что такое неявная ссылка this? В каких методах эта ссылка присутствует, а в каких – нет, и почему?

Как правило, применять this нужно в двух случаях:

1.	Когда у переменной экземпляра класса и переменной метода/конструктора одинаковые имена;
2.	Когда нужно вызвать конструктор одного типа (например, конструктор по умолчанию или параметризированный) из другого. Это еще называется явным вызовом конструктора.

Вот и все, на самом деле не так много, — всего два случая, когда применяется это страшное ключевое слово. Теперь давайте рассмотрим эти две ситуации на примерах.
https://javarush.ru/groups/posts/608-kljuchevoe-slovo-this-v-primerakh

##5.	Что такое финальные поля, какие поля можно объявить со спецификатором final? Где можно инициализировать финальные поля?

В java есть ключевое слово – final. Оно может применяться к классам, методам, переменным (в том числе аргументам методов).

Для класса это означает, что класс не сможет иметь подклассов, т.е. запрещено наследование. Это полезно при создании immutable (неизменяемых) объектов, например, класс String объявлен, как final.
```
public final class String{
}
class SubString extends String{ //Ошибка компиляции
}
Следует также отметить, что к абстрактным классам (с ключевым словом abstract), нельзя применить модификатор final, т.к. это взаимоисключающие понятия. Для метода final означает, что он не может быть переопределен в подклассах. Это полезно, когда мы хотим, чтобы исходную реализацию нельзя было переопределить.
public class SuperClass{
    public final void printReport(){
        System.out.println("Report");
    }
}
class SubClass extends SuperClass{
    public void printReport(){  //Ошибка компиляции
        System.out.println("MyReport");
    }
}
```
Для переменных примитивного типа это означает, что однажды присвоенное значение не может быть изменено. Для ссылочных переменных это означает, что после присвоения объекта, нельзя изменить ссылку на данный объект. Это важно! Ссылку изменить нельзя, но состояние объекта изменять можно.

С java 8 появилось понятие — effectively final. Применяется оно только к переменным (в том числе аргументам методов). Суть в том, что не смотря на явное отсутствие ключевого слова final, значение переменной не изменяется после инициализации. Другими словами, к такой переменной можно подставить слово final без ошибки компиляции. effectively final переменные могут быть использованы внутри локальных классов (Local Inner Classes), анонимных классов (Anonymous Inner Classes), стримах (Stream API).
```
public void someMethod(){
    // В примере ниже и a и b - effectively final, тк значения устанавливаютcя однажды:
    int a = 1;
    int b;
    if (a == 2) b = 3;
    else b = 4;
    // с НЕ является effectively final, т.к. значение изменяется
    int c = 10;
    c++;

    Stream.of(1, 2).forEach(s-> System.out.println(s + a)); //Ок
    Stream.of(1, 2).forEach(s-> System.out.println(s + c)); //Ошибка компиляции
}
```
##6.	Что такое статические поля, статические финальные поля и статические методы. К чему имеют доступ статические методы? Можно ли перегрузить и переопределить статические методы? Наследуются ли статические методы?

Static — модификатор, применяемый к полю, блоку, методу или внутреннему классу. Данный модификатор указывает на привязку субъекта к текущему классу.
При обозначении переменной уровня класса мы указываем на то, что это значение относится к классу. Если этого не делать, то значение переменной будет привязываться к объекту, созданному по этому классу. Что это значит?

А то, что если переменная не статическая, то у каждого нового объекта данного класса будет своё значение этой переменной, меняя которое мы меняем его исключительно в одном объекте: Например, у нас есть класс Car с нестатической переменной:
```
public class Car {
  int km;
}
Тогда в main:
Car orangeCar = new Car();
orangeCar.km = 100;

Car blueCar = new Car();
blueCar.km = 85;

System.out.println("Orange car - " + orangeCar.km);
System.out.println("Blue car - " + blueCar.km);
```
**Статический блок**

Есть два блока инициализации — обычный и статический. Блок предназначен для инициализации внутренних переменных. Если блок обычный, то им инициализируют внутренние переменные объекта, если же не статический, соответственно, им задают статические переменные (то есть переменные класса). 

**Пример класса с нестатическим блоком инициализации:**
```
public class Car {
  static int km;

  static {
     km = 150;
  }
}
```
**Статический метод**

Статические методы отличаются от обычных тем, что они также привязаны к классу, а не к объекту. Важным свойством статического метода является то, что он может обратиться только к статическим переменным/методам. В качестве примера давайте рассмотрим класс, который у нас будет неким счётчиком, ведущим учет вызовов метода:
```
public class Counter {
  static int count;

  public static void invokeCounter() {
     count++;
     System.out.println("Текущее значение счётчика - " + count);
  }
}
```

**Статический класс в Java**

Статическим классом может быть только внутренний класс. Опять же, этот класс привязан к внешнему классу, и если внешний наследуется другим классом, то этот не будет наследован. При этом данный класс можно наследовать, как и он может наследоваться от любого другого класса и имплементировать интерфейс. По сути статический вложенный класс ничем не отличается от любого другого внутреннего класса за исключением того, что его объект не содержит ссылку на создавший его объект внешнего класса. Тем не менее, благодаря этому статический класс наиболее похож на обычный не вложенный, ведь единственное различие состоит в том, что он упакован в другой класс. В некоторых случаях для нас это преимущество, так как с него у нас есть доступ к приватным статическим переменным внешнего класса. 

**Пример вложенного статического класса:**
```
public class Vehicle {

  public static class Car {
     public int km;
  }
}
```
Для использования статических методов/переменных/класса нам не нужно создавать объект данного класса. Конечно, следует учитывать модификаторы доступа. Например, поля private доступны только внутри класса, в котором они объявлены. Поля protected доступны всем классам внутри пакета (package), а также всем классам-наследникам вне пакета. Для более подробной информации ознакомьтесь со статьей “private vs protected vs public”. Предположим, существует статический метод increment() в классе Counter, задачей которого является инкрементирование счётчика count. Для вызова данного метода можно использовать обращение вида Counter.increment(). Нет необходимости создавать экземпляр класса Counter для доступа к статическому полю или методу. Это фундаментальное отличие между статическими и НЕ статическими объектами (членами класса). Еще раз напомню, что статические члены класса напрямую принадлежат классу, а не его экземпляру. То есть, значение статической переменной count будет одинаковое для всех объектов типа Counter. 

В этом разделе мы рассмотрим основные моменты использования статических методов, полей и классов. Начнём с переменных. 

1.	Вы НЕ можете получить доступ к НЕ статическим членам класса, внутри статического контекста, как вариант, метода или блока. Результатом компиляции приведенного ниже кода будет ошибка:

```
public class Counter{
private int count;
public static void main(String args[]){
   System.out.println(count); //compile time error
}}
```
Это одна из наиболее распространённых ошибок допускаемых программистами Java, особенно новичками. Так как метод main статичный, а переменная count нет, в этом случае метод println, внутри метода main выбросит “Compile time error”.

В отличие от локальных переменных, статические поля и методы НЕ потокобезопасны (Thread-safe) в Java. На практике это одна из наиболее частых причин возникновения проблем связанных с безопасностью мультипоточного программирования. Учитывая что каждый экземпляр класса имеет одну и ту же копию статической переменной, то такая переменная нуждается в защите — «залочивании» классом. Поэтому при использовании статических переменных, убедитесь, что они должным образом синхронизированы (synchronized), во избежание проблем, например таких как «состояние гонки» (race condition).

Статические методы имеют преимущество в применении, т.к. отсутствует необходимость каждый раз создавать новый объект для доступа к таким методам. Статический метод можно вызвать, используя тип класса, в котором эти методы описаны. Именно поэтому, подобные методы как нельзя лучше подходят в качестве методов-фабрик (factory), и методов-утилит (utility). Класс java.lang.Math — замечательный пример, в котором почти все методы статичны, по этой же причине классы-утилиты в Java финализированы (final).

Другим важным моментом является то, что вы НЕ можете переопределять (Override) статические методы. Если вы объявите такой же метод в классе-наследнике (subclass), т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса (superclass) вместо переопределения. Это явление известно как сокрытие методов (hiding methods). Это означает, что при обращении к статическому методу, который объявлен как в родительском, так и в дочернем классе, во время компиляции всегда будет вызван метод исходя из типа переменной. В отличие от переопределения, такие методы не будут выполнены во время работы программы. 

**Рассмотрим пример:**
```
class Vehicle{
     public static void  kmToMiles(int km){
          System.out.println("Внутри родительского класса/статического метода");
     } }

class Car extends Vehicle{
     public static void  kmToMiles(int km){
          System.out.println("Внутри дочернего класса/статического метода ");
     } }

public class Demo{
   public static void main(String args[]){
      Vehicle v = new Car();
       v.kmToMiles(10);
  }}
  ```
Объявить статическим также можно и класс, за исключением классов верхнего уровня. Такие классы известны как «вложенные статические классы» (nested static class). Они бывают полезными для представления улучшенных связей. Яркий пример вложенного статического класса — HashMap.Entry, который предоставляет структуру данных внутри HashMap. Стоит заметить, также как и любой другой внутренний класс, вложенные классы находятся в отдельном файле .class. Таким образом, если вы объявили пять вложенных классов в вашем главном классе, у вас будет 6 файлов с расширением .class. Ещё одним примером использования является объявление собственного компаратора (Comparator), например компаратор по возрасту (AgeComparator) в классе сотрудники (Employee).

Модификатор static также может быть объявлен в статичном блоке, более известным как «Статический блок инициализации» (Static initializer block), который будет выполнен во время загрузки класса. Если вы не объявите такой блок, то Java соберёт все статические поля в один список и выполнит его во время загрузки класса. Однако, статичный блок НЕ может пробросить перехваченные исключения, но может выбросить не перехваченные. В таком случае возникнет «Exception Initializer Error». На практике, любое исключение возникшее во время выполнения и инициализации статических полей, будет завёрнуто Java в эту ошибку. Это также самая частая причина ошибки «No Class Def Found Error», т.к. класс не находился в памяти во время обращения к нему.

Полезно знать, что статические методы связываются во время компиляции, в отличие от связывания виртуальных или не статических методов, которые связываются во время исполнения на реальном объекте. Следовательно, статические методы не могут быть переопределены в Java, т.к. полиморфизм во время выполнения не распространяется на них. Это важное ограничение, которое необходимо учитывать, объявляя метод статическим. В этом есть смысл, только тогда, когда нет возможности или необходимости переопределения такого метода классами-наследниками. Методы-фабрики и методы-утилиты хорошие образцы применения модификатора static. Джошуа Блох выделил несколько преимуществ использования статичного метода-фабрики перед конструктором, в книге «Effective Java», которая является обязательной для прочтения каждым программистом данного языка.

Важным свойством статического блока является инициализация. Статические поля или переменные инициализируются после загрузки класса в память. Порядок инициализации сверху вниз, в том же порядке, в каком они описаны в исходном файле Java класса. Поскольку статические поля инициализируются на потокобезопасный манер, это свойство также используется для реализации паттерна Singleton. Если вы не используется список Enum как Singleton, по тем или иным причинам, то для вас есть хорошая альтернатива. Но в таком случае необходимо учесть, что это не «ленивая» инициализация. Это означает, что статическое поле будет проинициализировано ещё ДО того как кто-нибудь об этом «попросит». Если объект ресурсоёмкий или редко используется, то инициализация его в статическом блоке сыграет не в вашу пользу.

Во время сериализации, также как и transient переменные, статические поля не сериализуются. Действительно, если сохранить любые данные в статическом поле, то после десериализации новый объект будет содержать его первичное (по-умолчанию) значение, например, если статическим полем была переменная типа int, то её значение после десериализации будет равно нулю, если типа float – 0.0, если типа Object – null. Честно говоря, это один из наиболее часто задаваемых вопросов касательно сериализации на собеседованиях по Java. Не храните наиболее важные данные об объекте в статическом поле!

И напоследок, поговорим о static import. Данный модификатор имеет много общего со стандартным оператором import, но в отличие от него позволяет импортировать один или все статические члены класса. При импортировании статических методов, к ним можно обращаться как будто они определены в этом же классе, аналогично при импортировании полей, мы можем получить доступ без указания имени класса. Данная возможность появилась в Java версии 1.5, и при должном использовании улучшает читабельность кода. Наиболее часто данная конструкция встречается в тестах JUnit, т.к. почти все разработчики тестов используют static import для assert методов, например assertEquals() и для их перегруженных дубликатов

##7.	Что такое логические и статические блоки инициализации? Сколько их может быть в классе, в каком порядке они могут быть размещены и в каком порядке вызываются?

**Переменные**

Переменные (variables) - это контейнеры, которые хранят какие-либо данные. Посмотрим официальный Tutorial от Oracle : Declaring Member Variables. Согласно данному Tutorial, существует несколько типов переменных: 

•	Поля (fields) : переменные, объявленные в классе;
•	Локальные переменные (local variables) : переменные в методе или в блоке кода;
•	Параметры (parameters) : переменные в объявлении метода (в сигнатуре).

Все переменные должны иметь тип переменной и название переменной. 

Тип переменной показывает, какие данные представляет данная переменная (т.е. какие данные может хранить). Как мы знаем, тип переменной может быть примитивным (primitives primitives) или объектным, не примитивными (Non-primitive). При объектных переменных их тип описывается определённым классом.

Название переменной должно быть с маленькой буквы, в camel case. Подробнее про именование можно прочитать в "Variables:Naming".

Так же если переменная уровня класса, т.е. является полем класса, то для неё может указываться модификатор доступа. Подробнее см. Controlling Access to Members of a Class.

**Объявление переменной (Declaration)**

Итак, мы вспомнили, что такое переменная. Для того, чтобы с переменной начать работать нужно её объявить. Для начала, разберёмся с локальной переменной. Вместо IDE для удобства воспользуемся онлайн решением от tutorialspoint: Online IDE. Выполним в их online IDE вот такую простенькую программку:
```
public class HelloWorld{
    public static void main(String []args){
        int number;
        System.out.println(number);
    }
}
```
Итак, как видно, мы объявили локальную переменную с именем number и типом int. Нажимаем кнопку «Execute» и получаем ошибку:
```
HelloWorld.java:5: error: variable number might not have been initialized
        System.out.println(number);
  ```      
Что же произошло? Мы объявили переменную, но значение её не инициализировали. Стоит заметить, что ошибка эта произошла не в момент выполнения (т.е. не в Runtime), а в момент компиляции. Умный компилятор проверил, будет ли локальная переменная инициализирована до обращения к ней или нет. Поэтому, из этого следует следующие утверждения: 

Обращение к локальным переменным должно быть выполнено только после того, как они будут инициализированы;

Локальные переменные не имеют значений по умолчанию;

Проверка значений локальных переменных выполняется в момент компиляции.

Итак, нам говорят, что переменная должна быть проинициализирована. Инициализация переменной – присвоение переменной значения. Давайте тогда разбираться, что это и почему.

**Инициализация локальной переменной**

Инициализация переменных одна из самых мудрёных тем в Java, т.к. очень тесно связана с работой с памятью, с реализацией JVM, спецификацией JVM и другими не менее страшными и хитрыми вещами. Но можно попробовать разобраться хоть в какой-то мере. Пойдём от простого к сложному. Чтобы инициализировать переменную воспользуемся оператором присваивания и изменим строчку в нашем прошлом коде:
```
int number = 2;
```
В таком варианте ошибок не будет и на экран выведется значение. Что же происходит в этом случае? Давайте попробуем порассуждать. Если мы хотим присвоить переменной какое-то значение, значит мы хотим, чтобы эта переменная хранила значение. Получается, что значение где-то должно храниться, но где? На диске? Но это очень медленно и может на нас накладывать ограничения. Получается, единственное, где мы можем быстро и эффективно хранить данные «здесь и сейчас» это память. Значит, нам нужно выделить в памяти какое-то место. Так и есть. При инициализации переменной под неё будет выделено место в памяти, отведённой java процессу, в рамках которого будет выполняться наша программа. Память, выделяемая java процессу, разделена на несколько областей или зон. В какой из них будет выделено место зависит от того, какого типа была объявлена переменная. Память разделяется на следующие разделы: Heap, Stack и Non-Heap. Начнём со стэковой памяти. Stack переводится как стопка (например, стопка книг). Представляет собой LIFO структуру данных (Last In, First Out). То есть как стопка книг. Когда мы добавляем в неё книги – мы кладём их сверху, а когда забираем – берём верхнюю (т.е. ту, которая добавлена самой последней). Итак, мы запускаем нашу программу. Как мы знаем, Java программу выполняет JVM, то есть виртуальная Java машина. JVM должна знать то, откуда должно начаться выполнение программы. Для этого мы объявляем main метод, который называется «точкой входа». Для выполнения в JVM создаётся основной поток (Thread). При создании потока ему выделяется свой стэк в памяти. Этот стэк состоит из фрэймов. При выполнении каждого нового метода в потоке под него будет выделен новый фрэйм и добавлен на вершину стэка (как новая книжка в стопке книг). Этот фрэйм будет содержит ссылки на объекты и примитивные типы. Да да, наш int будет храниться в стэке, т.к. int это примитивный тип. Прежде чем выделить фрэйм JVM должна понимать, что туда сохранять. Именно по этой причине мы получим ошибку «variable might not have been initialized», ведь если она не инициализирована, то JVM не сможет нам подготовить стэк. Поэтому при компиляции программы умный компилятор поможет нам не допустить ошибку и не сломать всё. (!) Для наглядности советую супер-пупер статью: "Java Stack and Heap: Java Memory Allocation Tutorial".

После завершения выполнения метода из стэка потока будут удаляться фрэймы, выделенные под эти методы, а вместе с ними и очищаться память, выделенная под этот фрэйм со всеми данными. 
Инициализация локальных объектных переменных

Давайте опять изменим наш код на чуть более хитрый:
```
public class HelloWorld{
    private int number = 2;
    public static void main(String []args){
        HelloWorld object = new HelloWorld();
        System.out.println(object.number);
    }
}
```
Что же тут будет происходить? Давайте ещё раз рассуждать. JVM узнает о том, откуда ей выполнять программу, т.е. она видит main метод. Она создаёт поток, под него выделяет память (потоку ведь надо где-то хранить данные, которые нужны для выполнения). В этом потоке выделяется фрэйм под метод main. Далее мы создаём объект HelloWorld. Этот объект уже создаётся не в стэке, а в хипе. Потому что object у нас не примитивный тип, а объектный. А в стэке будет храниться только ссылка на объект в хипе (мы ведь как-то должны обращаться к этому объекту). Далее в стэке метода main будут выделены фрэймы для выполнения метода println. После выполнения метода main будут уничтожены все фрэймы. При уничтожении фрэйма будут уничтожены все данные. Объект object не будет уничтожен сразу. Сначала на него будет уничтожена ссылка и таким образом на объект object больше никто ссылаться не будет и доступа больше к этому объекту в памяти будет не получить. Умная JVM имеет свой механизм для такого – сборщик мусора (garbage collector или сокращённо GC). Он то и удаляет из памяти такие объекты, на которые больше никто не ссылается. Данный процесс опять же был описан в ссылке, что была приведена выше. Там даже видео есть с объяснением.

**Инициализация полей**

Инициализация полей, указанных в классе происходит особым образом в зависимости от того, является ли поле статическим или нет. Если у поля стоит ключевое слово static, то данное поле относится к самому классу, а не слово static не указано, то данное поле относится к экземпляру класса. Давайте рассмотрим это на примере:

В данном примере, инициализация полей происходит в разное время. Поле number будет инициализировано после того, как будет создан объект object класса HelloWorld. А вот поле count будет инициализировано тогда, когда класс будет загружен виртуальной Java машиной. Загрузка классов – это отдельная тема, поэтому не будем сюда примешивать её. Просто стоит знать, что статические переменные инициализируются тогда, когда о классе становится известно при выполнении. Тут важнее другое и Вы уже это заметили. Мы нигде не указали значения, а оно работает. И действительно. Переменные, которые являются полями, если для них не указано значение, то они инициализируются значением по умолчанию. Для числовых значением это 0 или 0.0 для чисел с плавающей точкой. Для boolean это false. А для всех переменных объектных типов значение будет null (об этом мы ещё поговорим). Казалось бы, а почему так? А потому, что объекты создаются в Heap (в куче). Работа с данной областью выполняется в Runtime. И мы в runtime можем инициализировать эти переменные, в отличии от стэка, память под который должна быть подготовлена ещё до выполнения. Так устроена работа с памятью в Java. Но есть тут и ещё одна особенность. В этом маленьком кусочке затрагиваются разные уголки памяти. Как мы помним, в Stack памяти под метод main выделяется фрэйм. В этом фрэйме хранится ссылка (reference) на объект в Heap памяти. Но где тогда хранится count? Как мы помним, эта переменная инициализируется сразу, до создания объекта в хипе. Вот тут действительно хитрый вопрос. До Java 8 существовала область памяти, называемая PERMGEN. Начиная с Java 8 эта область претерпела изменения и называется METASPACE. По сути, статические переменные являются частью описания класса, т.е. его метаданными. Поэтому, логично, что хранится в хранилище метаданных, METASPACE. MetaSpace относится к той самой Non-Heap области памяти, является её частью. Важно ещё учитывать то, что учитывается порядок, в котором объявлены переменные. Например, в этом коде ошибка:
```
public class HelloWorld{

    private static int b = a;
    private static int a = 1;

    public static void main(String []args){
        System.out.println(b);
    }
}
```
**Блоки инициализации**

Виды блоков инициализации
Существует всего два типа блоков:
нестатический (instance initializer)
статический (class initializer)

статический блок используется для инициализации статических переменных, а "обычный"  - для всех остальных.


Рассматривая инициализацию переменных грех не рассмотреть блоки инициализации. Выглядит это следующим образом:
public class HelloWorld{
```
    static {
        System.out.println("static block");
    }
    {
        System.out.println("block");
    }
    public HelloWorld () {
        System.out.println("Constructor");
    }
    public static void main(String []args){
        HelloWorld obj = new HelloWorld();
    }
}
```
Порядок вывода будет: static block, block, Constructor. Как мы видим, блоки инициализации выполняются раньше, чем конструктор. И иногда это может быть удобным средством для инициализации.

##8.	Что представляют собой методы с переменным числом параметров, как передаются параметры в такие методы и что представляет собой такой параметр в методе? Как осуществляется выбор подходящего метода, при использовании перегрузки для методов с переменным числом параметров?

В языке Java существуют методы, которые могут принимать переменное количество аргументов. Они называются методами с аргументами переменной длины (var-args).
Для указания аргументов переменной длины служат три точки. 

**Например:**
```
static void test(int... array)
```
Наряду с параметром переменной длины у метода могут быть и "обычные" параметры. Но параметр переменной длины должен быть последним среди всех параметров, объявляемых в методе. 

**Например:**
```
static void test(double d, int... array)
```
Метод может содержать только один параметр с переменным количеством аргументов.
Применение аргументов переменной длины

В следующем примере показан метод test(), объявленный с переменным количеством аргументов типа int. Внутри метода мы обращаемся к этим переменным как к массиву. При вызове этого метода можно передать любое, даже нулевое количество аргументов, а также массив:
```
public class VarArgs {
    static void test(int... array) {
        System.out.println("Количество аргументов: " + array.length);
        for (int a : array) {
            System.out.print(a + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        test();
        test(1);
        test(1, 2);
        test(new int[]{1, 3});
    }
}
```
Методы с переменным числом аргументов можно перегружать. 

**Рассмотрим пример:**

**Перегрузка методов с аргументами переменной длины**

При вызове метода без аргументов, подходят два метода - test(double... array) и test(int... array). В этом случае будет вызван метод с меньшим диапазоном значений - test(int... array).
При вызове метода test() с одним значением типа int -  test(3), будет выбран метод test(int a).
```
public class VarArgs2 {
    static void test(double... array) {
        System.out.println("test(double... array)");
        System.out.println("Количество аргументов: " + array.length);
        for (double a : array) {
            System.out.print(a + " ");
        }
        System.out.println();
    }

    static void test(int... array) {
        System.out.println("test(int... array)");
        System.out.println("Количество аргументов: " + array.length);
        for (int a : array) {
            System.out.print(a + " ");
        }
        System.out.println();
    }

    static void test(int a) {
        System.out.println("test(int a)");
    }

    public static void main(String[] args) {
        test();
        test(3);
        test(1.0);
        test(1, 2);
    }
}
```
Результат выполнения:
```
test(int... array)
Количество аргументов: 0

test(int a)
test(double... array)
Количество аргументов: 1
1.0
test(int... array)
```
Количество аргументов: 2
1 2
При перегрузке метода, принимающего аргументы переменной длины, могут происходить непредвиденные ошибки. Они связаны с неоднозначностью, которая может возникать при вызове перегружаемого метода с аргументами переменной длины.
В следующем примере метод test перегружен - один вариант принимает значения var-ags типа boolean, а второй тоже var-ags, но типа int. При вызове метода test() без аргументов, возникает ошибка неоднозначности - JVM не может выбрать необходимый метод. 

##9.	Чем является класс Object? Перечислите известные вам методы класса  Object, укажите их назначение.

В Java есть специальный суперкласс Object и все классы являются его подклассами. Поэтому ссылочная переменная класса Object может ссылаться на объект любого другого класса. Так как массивы являются тоже классами, то переменная класса Object может ссылаться и на любой массив.

Все классы являются наследниками суперкласса Object. Это не нужно указывать явно. В результате объект Object может ссылаться на объект любого другого класса.

**Методы класса  Object:**

•	public final native Class getClass() – возвращает в рантайме класс данного объекта.
•	public native int hashCode() – возвращает хеш-код
•	public boolean equals(Object obj) – сравнивает объекты.
•	protected native Object clone() throws CloneNotSupportedException – клонирование объекта
•	public String toString() – возвращает строковое представление объекта.
•	public final native void notify() – просыпается один поток, который ждет на “мониторе” данного объекта.
•	public final native void notifyAll() – просыпаются все потоки, которые ждут на “мониторе” данного объекта.
•	public final native void wait(long timeout) throws InterruptedException – поток переходит в режим ожидания в течение указанного времени.
•	public final void wait() throws InterruptedException – приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() методы для этого объекта.
•	public final void wait(long timeout, int nanos) throws InterruptedException – приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() для этого метода, или пока не истечет указанный промежуток времени.
•	protected void finalize() throws Throwable – вызывается сборщиком мусора, когда garbage collector определил, что ссылок на объект больше нет.



##10.	Что такое хэш-значение? Объясните, почему два разных объекта могут сгенерировать одинаковые хэш-коды?

Функция hash - это способ создания компактного представления произвольно большого объема данных. В java с помощью метода hashcode это означает, что каким-то образом описывается состояние вашего объекта (независимо от его размера) в int (4 байта). И обычно пишется довольно быстро, как описано ниже.

Функция HASH: - функция hash берет группу символов (называемую ключом) и сопоставляет ее со значением определенной длины (называемым значением hash или hash). Значение hash является репрезентативным для исходной строки символов, но обычно меньше, чем оригинал. Хэширование выполняется для индексирования и поиска элементов в базах данных, поскольку более короткое значение hash легче найти, чем более длинную строку. Хэширование также используется в шифровании. Этот термин также известен как алгоритм хэширования или функция дайджеста сообщений.

•	У одинаковых объектов всегда одинаковые хеши
•	У одного и того же объекта всегда должен быть неизменяемый хешкод(если значения внутри объекта не изменились)
•	У разных объектов иногда могут быть одинаковые хеши
 Если два объекта равны в соответствии с equal(), то вызов метода hashcode для каждого из этих двух объектов должен выдавать один и тот же хэш-код
 ```
public class Test {
    public static void main(String[] args) {

        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        map.put(1, 11);
        map.put(4, 11);
        System.out.println(map.hashCode());
        Map<Integer, Integer> map1 = new HashMap<Integer, Integer>();
        map1.put(1, 11);
        map1.put(4, 11);
        System.out.println(map1.hashCode());
        if (map.equals(map1)) {
            System.out.println("equal ");
        }
    }
}
```
##11.	Что такое объект класса Class? Чем использование метода getClass() и последующего сравнения возвращенного значения с Type.class отличается от использования оператора instanceof?

Класс в Java - это шаблон для создания объекта, а объект - это экземпляр класса. ... Класс содержит переменные и методы, которые называются элементами класса, членами класса. Он составляет основу инкапсуляции в Java. Каждый объект данного класса содержит структуру и поведение, которые определены классом.

Способ getClass() будет работать быстрее, чем instanceof, т.к. это только лишь сравнение ссылок.

getClass() сравнивает лишь на конкретный класс, instanceof смотрит и подклассы.

##12.	Укажите правила переопределения методов equals(), hashCode() и toString().

Метод еquals() используется для сравнения объектов, а hashCode - для генерации целочисленного кода объекта.

Эти методы широко используются в стандартных библиотеках Java при вставке и извлечению объектов в HashMap. Метод equal также используется для обеспечения хранения только уникальных объектов в HashSet и других Set реализациях, а также в любых других случаях, когда нужно сравнивать объекты. Реализация по умолчанию метода equals() в классе java.lang.Object сравнивает ссылки на адреса в памяти, которые хранят переменные, и возвращает true только в том случае, если адреса совпадают, другими словами переменные ссылаются на один и тот же объект. Java рекомендует переопределять методы equals() и hashCode(), если предполагается, что сравнение должно осуществляться в соответсвии с естественной логикой или бизнес-логикой. Многие классы в стандартных библиотеках Java переопределяет их, например в классе String переопределяется equals таким образом, что возвращается true, если содержимое двух сравниваемых объектов одинаковое. В классе-обертке Integer метод equal переопределяется для выполнения численного сравнения, и так далее. Так как HashMap и HashTable в Java полагаются на методы equals() и hashCode() для сравнения своих key и values, то Java предлагает следующие правила для переопределения этих методов: 

Рефлексивность: Объект должен равняться себе самому.

Симметричность: если a.equals(b) возвращает true, то b.equals(a) должен тоже вернуть true.

Транзитивность: если a.equals(b) возвращает true и b.equals(c) тоже возвращает true, то
c.equals(a) тоже должен возвращать true.

Согласованность: повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор, пока какое-либо значение свойств объекта не будет изменено. То есть, если два объекта равны в Java, то они будут равны пока их свойства остаются неизменными.
Сравнение null: объект должны быть проверен на null. Если объект равен null, то метод должен вернуть false, а не NullPointerException. Например, a.equals(null) должен вернуть false.
Соглашение между equals и hashCode в Java

Если объекты равны по результатам выполнения метода equals, тогда их hashcode должны быть одинаковыми.

Если объекты не равны по результатам выполнения метода equals, тогда их hashcode могут быть как одинаковыми, так и разными. Однако для повышения производительности, лучше, чтобы разные объекты возвращали разные коды.

Как переопределять метод equals в Java
```
@Override
public boolean equals(Object obj) {
/*1. Проверьте*/if (obj == this) {
/*и верните */ return true;
         }
```
Проверьте объект на null, а также проверьте, чтобы объекты были одного типа. Не делайте проверку с помощью instanceof так как такая проверка будет возвращать true для подклассов и будет работать правильно только в случае если ваш класс объявлен как immutable. Вместо этого можно использовать getClass();
```
if (obj == null || obj.getClass() != this.getClass()) {
            return false;
}
```
Объявите переменную типа, который вы сравниваете, и приведите obj к этому типу. Потом сравнивайте каждый атрибут типа начиная с численных атрибутов (если имеются) потому что численные атрибуты проверяются быстрей. Сравнивайте атрибуты с помощью операторов И и ИЛИ (так называемые short-circuit logical operators) для объединения проверок с другими атрибутами.
```
Person guest = (Person) obj;
        return id == guest.id && (firstName == guest.firstName ||
            (firstName != null && firstName.equals(guest.getFirstName())))
                && (lastName == guest.lastName || (lastName != null &&                      lastName .equals(guest.getLastName())));
}
```
Полный пример переопределения метода equals в Java
```
/** * Person class with equals and hashcode implementation in Java * @author Javin Paul */
public class Person {
    private int id;
    private String firstName;
    private String lastName;

    public int getId() { return id; }
    public void setId(int id) { this.id = id;}

    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }
    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
    @Override
    public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (obj == null || obj.getClass() != this.getClass()) {
        return false;
    }

    Person guest = (Person) obj;
    return id == guest.id
        && (firstName == guest.firstName
            || (firstName != null &&firstName.equals(guest.getFirstName())))        && (lastName == guest.lastName
            || (lastName != null && lastName .equals(guest.getLastName())
            ));
    }
    @Override
    public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((firstName == null) ? 0 : firstName.hashCode());             result = prime * result + id; result = prime * result +
        ((lastName == null) ? 0 : lastName.hashCode()); return result;
    }
 }
 ```
Распространенные ошибки при переопределении equals в Java

Вместо того, чтобы переопределять метод equals (Override) программист перегружает его (Overload)Синтаксис метода equals() в классе Object определен как public boolean equals(Object obj), но многие программисты ненароком перегружают метод: public boolean equals(Person obj) - вместо Object в качестве аргумента используют имя своего класса (напр. Person). Эту ошибку сложно обнаружить из-за static binding. Таким образом, если вы вызовите этот метод для объекта своего класса, то метод не просто скомпилируется, а даже сделает это корректно. Однако, если вы положите ваш объект в коллекцию, например ArrayList и вызовите метод contains(), работа которого основана на методе equals(), то метод contains не сможет обнаружить ваш объект.

При переопределении метода equals() не проверять на null переменные, что в конечном итоге заканчивается NullPointerException при вызове equals()

Третья распространенная ошибка это не переопределять метод hashCode(), а только equals(). Вы обязаны переопределять оба метода equals() и hashCode() в Java. Метод hashCode используется в hash -коллекциях(например HashSet), и чем меньше будет коллизий (одинаковый код при разных объектах) тем эффективнее эти коллекции будут работать с объектами вашего класса.

Последняя распространенная ошибка программистов в том, что при переопределении метода equals() не сохраняется соответствие между методами equals() и compareTo(), что является неформальным требованием для избежания хранения дубликатов в Set (SortedSet, TreeSet).

toString метод в Java используется для предоставления ясной и достаточной информации об объекта (Object) в удобном для человека виде. Правильное переопределение метода toString может помочь в ведении журнала работы и в отладке Java программы предоставляя ценную и важную информацию. Поскольку toString() определен в java.lang.Object класса и его реализация по умолчанию не предоставляет много информации, всегда лучшей практикой является переопределение данного метода в классе-потомке.

Фактически, если вы создаете важный или общий класс типа Order, Trade или Employee, всегда переопределяйте equals, hashCode, compareTo и toString методы в Java. По умолчанию реализация toString создает вывод в виде package.class@hashCode, к примеру для нашего примера toString(), toString() метод класса Country напечатает test.Country@18e2b22 где 18e2b22 это хэш-код объекта в шестнадцатеричном виде, если вы вызовете hashCode метод то он вернет 260943370, что является десятеричным эквивалентом 18e2b22. Эта информация не особо полезна во время поиска какой-либо проблемы. Давайте посмотрим на пример из реальной жизни где вам нужно найти проблему в соединении с сетью, в том случае если вы хотите знать с каким именно хостом и портом пытается соединиться ваша система и если Socket или ServerSocket печатает только информацию toString по умолчанию, то будет невозможно представить реальную проблему, но с переопределенной реализацией toString они могут предоставить полезную информацию, такую как имя хоста и номер порта. В этой Java-консультации мы дадим несколько подсказок по переопределению метода toString с примерами кода.

Как переопределить метод toString в Java:
Печать форматированной даты(т.е. день/месяц/год) вместо "сырого" значения. Это очень полезная подсказка при переопределении Java-метода toString. Обычный toString() класса java.util.Date не выводит форматированную дату и включает много деталей, которые не всегда нужны. Если вы используете частичный DateFormat т.е. dd-MM-yy в вашем приложении, то вы определенно хотели бы видеть этот формат вместо данного по умолчанию. IDE обычно не генерирует форматированный вывод Date и это то, что вам нужно сделать самому, но это того стоит. Прочитайте Как распечатать Date в формате ddMMyy в Java где детально описано форматирование Date в Java. Вы так же можете использовать SimpleDataFormat класс или библиотеку Joda Date time для этого.
