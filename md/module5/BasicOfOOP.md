# Basic of OOP

## OOP, Classes and Objects, Inheritance, Class Object, Interfaces

### 1. Дайте развернутое объяснение трем концепциям ООП.

Java является объектно-ориентированным языком. Это означает, что писать программы на Java нужно с применением
объектно-ориентированного стиля. И стиль этот основан на использовании в программе объектов и классов.

**Основные принципы ООП:**

* Абстракция
* Инкапсуляция
* Наследование
* Полиморфизм

Попробуем с помощью примеров разобраться, что такое классы и объекты, а также с тем, как применять на практике основные
принципы ООП: абстракцию, наследование, полиморфизм и инкапсуляцию.

**Что такое объект?**

Мир, в котором мы живем, состоит из объектов. Если мы посмотрим вокруг, то увидим, что нас окружают дома, деревья,
автомобили, мебель, посуда, компьютеры. Все эти предметы являются объектами, и каждый из них обладает набором
определенных характеристик, поведением и назначением.

Мы привыкли к объектам, и мы их используем всегда для вполне конкретных целей. Например, если нам необходимо доехать до
работы, мы пользуемся автомобилем, если захотим поесть – посудой, а если отдохнуть – нам понадобится удобный диван.

Человек привык мыслить объектно для решения задач в повседневной жизни. Это послужило одной из причин использования
объектов в программировании, а такой подход к созданию программ назвали объектно-ориентированным.

Приведём пример. Представьте, что вы разработали новую модель телефона и хотите наладить её серийное производство. Как
разработчик телефона, вы знаете для чего он нужен, как он будет функционировать, и из каких деталей он будет состоять (
корпус, микрофон, динамик, провода, кнопки и т.д.). При этом только вы знаете, как соединить эти детали.

Однако вы не планируете выпускать телефоны лично, для этого у вас есть целый штат работников. Чтобы вам не пришлось
каждый раз объяснять, как соединить детали телефона, и чтобы все телефоны при производстве получались одинаковыми,
прежде чем начать их выпуск, вам понадобиться сделать чертеж в виде описания устройства телефона. В ООП такое описание,
чертеж, схема или шаблон называется классом, из которого при выполнении программы создается объект.

*Класс* — это описание еще не созданного объекта, как бы общий шаблон, состоящий из полей, методов и конструктора, а
объект – экземпляр класса, созданный на основе этого описания.

**Абстракция ООП**

Давайте теперь подумаем, как нам перейти от объекта из реального мира к объекту в программе на примере телефона. История
этого средства связи превышает 100 лет и современный телефон, в отличие от своего предшественника из 19 века,
представляет собой куда более сложное устройство.

Когда мы пользуемся телефоном, то не задумываемся о его устройстве и процессах, происходящих внутри него. Мы просто
используем функции, предоставленные разработчиками телефона — кнопки или сенсорный экран для выбора номера и совершения
вызовов.

Одним из первых интерфейсов телефона была рукоятка, которую нужно было вращать, чтобы сделать вызов. Разумеется, это
было не очень удобно. Тем не менее, свою функцию рукоять исправно выполняла.

Если посмотреть на самый современный и на самый первый телефон, можно сразу выделить самые важные детали, которые важны
и для устройства конца 19-го века, и для суперсовременного смартфона. Это совершение вызова (набор номера) и приём
вызова. По сути это то, что делает телефон телефоном, а не чем-то другим. Сейчас мы применили принцип в ООП — выделение
наиболее важных характеристик и информации об объекте. Этот принцип ООП называется абстракцией.

Абстракцию в ООП можно также определить, как способ представления элементов задачи из реального мира в виде объектов в
программе. Абстракция всегда связана с обобщением некоторой информации о свойствах предметов или объектов, поэтому
главное — это отделить значимую информацию от незначимой в контексте решаемой задачи. При этом уровней абстракции может
быть несколько.

Попробуем применить принцип абстракции к нашим телефонам. Для начала выделим наиболее распространённые типы телефонов от
самых первых и до наших дней. Например, их можно представить в виде диаграммы, приведенной на рисунке 1.

![рисунок 1](https://cdn.javarush.ru/images/article/231fecfa-b0f7-46d0-9500-32d1cdced5e2/800.webp)

Теперь с помощью абстракции мы можем выделить в этой иерархии объектов общую информацию: общий абстрактный тип объектов
— телефон, общую характеристику телефона — год его создания, и общий интерфейс — все телефоны способны принимать и
посылать вызовы.

**Вот как это выглядит на Java:**

    public abstract class AbstractPhone {
    private int year;

    public AbstractPhone(int year) {
        this.year = year;
    }
    public abstract void call(int outputNumber);
    public abstract void ring (int inputNumber);
    }   

На основании этого абстрактного класса мы сможем создавать в программе новые типы телефонов с использованием других
базовых принципов ООП Java, которые рассмотрим ниже.

**Инкапсуляция**

С помощью абстракции мы выделяем общее для всех объектов. Однако каждая модель телефона — индивидуальна и чем-то
отличается от других. Как же нам в программе провести границы и обозначить эту индивидуальность?

Как сделать так, чтоб никто из пользователей случайно или преднамеренно не смог сломать наш телефон, или попытаться
переделать одну модель в другую? Для мира реальных объектов ответ очевиден: нужно поместить все детали в корпус
телефона. Ведь если этого не сделать и оставить все внутренности телефона и провода, соединяющие их снаружи, обязательно
найдется любознательный экспериментатор, который захочет “улучшить” работу нашего телефона. Для исключения подобного
вмешательства в конструкцию и работу объекта в ООП используют принцип инкапсуляции – еще один базовый принцип ООП, при
котором атрибуты и поведение объекта объединяются в одном классе, внутренняя реализация объекта скрывается от
пользователя, а для работы с объектом предоставляется открытый интерфейс.

Задача программиста — определить, какие атрибуты и методы будут доступны для открытого доступа, а какие являются
внутренней реализацией объекта и должны быть недоступны для изменений.

**Инкапсуляция и управление доступом**

Допустим, при производстве на тыльной стороне телефона гравируется информация о нем: год его выпуска или логотип
компании производителя. Эта информация вполне конкретно характеризует данную модель — его состояние. Можно сказать,
разработчик телефона позаботился о неизменности этой информации — вряд ли кому-то придет в голову удалять гравировку.

В мире Java состояние будущих объектов описывается в классе с помощью полей, а их поведение – с помощью методов.
Возможность же изменения состояния и поведения осуществляется с помощью модификаторов доступа к полям и методам –
private, protected, public, а также default (доступ по умолчанию).

Например, мы решили, что год создания, название производителя телефона и один из методов относятся к внутренней
реализации класса и не подлежат изменению другими объектами в программе.

**С помощью кода класс можно описать так:**

    public class SomePhone {

    private int year;
    private String company;
    public SomePhone(int year, String company) {
        this.year = year;
        this.company = company;
    }
    private void openConnection(){
    //findComutator
    //openNewConnection...
    }
    public void call() {
    openConnection();
    System.out.println("Вызываю номер");
    }
        p  ublic void ring() {
    System.out.println("Дзынь-дзынь");
    }
        }

Модификатор private делает доступными поля и методы класса только внутри данного класса. Это означает, что получить
доступ к private полям из вне невозможно, как и нет возможности вызвать private методы.

Сокрытие доступа к методу openConnection, оставляет нам также возможность к свободному изменению внутренней реализации
этого метода, так как этот метод гарантированно не используется другими объектами и не нарушит их работу.

Для работы с нашим объектом мы оставляем открытыми методы call и ring с помощью модификатора public. Предоставление
открытых методов для работы с объектом также является частью механизма инкапсуляции, так как если полностью закрыть
доступ к объекту – он станет бесполезным.

**Наследование**

Давайте посмотрим еще раз на диаграмму телефонов. Можно заметить, что она представляет собой иерархию, в которой модель,
расположенная ниже обладает всеми признаками моделей, расположенных выше по ветке, плюс своими собственными. Например,
смартфон, использует сотовую сеть для связи (обладает свойствами сотового телефона), является беспроводным и
переносным (обладает свойствами беспроводного телефона) и может принимать и делать вызовы (свойствами телефона). В этом
случае мы можем говорить о наследовании свойств объекта.

В программировании наследование заключается в использовании уже существующих классов для описания новых.

Рассмотрим пример создания класса смартфон с помощью наследования. Все беспроводные телефоны работают от аккумуляторных
батарей, которые имеют определенный ресурс работы в часах.

**Поэтому добавим это свойство в класс беспроводных телефонов:**

    public abstract class WirelessPhone extends AbstractPhone {
        private int hour;
        public WirelessPhone(int year, int hour) {
            super(year);
            this.hour = hour;
        }
    }

**Сотовые телефоны наследуют свойства беспроводного телефона, мы также добавили в этот класс реализацию методов call и ring:**

    public class CellPhone extends WirelessPhone {
    public CellPhone(int year, int hour) {
    super(year, hour);
    }
    
        @Override
        public void call(int outputNumber) {
            System.out.println("Вызываю номер " + outputNumber);
        }
    
        @Override
        public void ring(int inputNumber) {
            System.out.println("Вам звонит абонент " + inputNumber);
        }
    }

И, наконец, класс смартфон, который в отличие от классических сотовых телефонов имеет полноценную операционную систему. В смартфон можно добавлять новые программы, поддерживаемые данной операционной системой, расширяя, таким образом, его функциональность. 

**С помощью кода класс можно описать так:**

    public class Smartphone extends CellPhone {
    
        private String operationSystem;
    
        public Smartphone(int year, int hour, String operationSystem) {
            super(year, hour);
            this.operationSystem = operationSystem;
        }
    public void install(String program){
    System.out.println("Устанавливаю " + program + "для" + operationSystem);
    }
    
    }

Как видите, для описания класса Smartphone мы создали совсем немного нового кода, но получили новый класс с новой функциональностью. Использование принципа наследование ООП позволяет значительно уменьшить объем кода, а значит, и облегчить работу программисту.

**Полиморфизм**

Если мы посмотрим на все модели телефонов, то, несмотря на различия во внешнем облике и устройстве моделей, мы можем выделить у них некое общее поведение – все они могут принимать и совершать звонки и имеют достаточно понятный и простой набор кнопок управления. Применяя известный нам уже один из основных принципов ООП абстракцию в терминах программирования можно сказать, что объект телефон имеет один общий интерфейс. Поэтому пользователи телефонов могут вполне комфортно пользоваться различными моделями, используя одни и те же кнопки управления (механические или сенсорные), не вдаваясь в технические тонкости устройства. Так, вы постоянно пользуетесь сотовым телефоном, и без труда сможете совершить звонок с его стационарного собрата.

Принцип в ООП, когда программа может использовать объекты с одинаковым интерфейсом без информации о внутреннем устройстве объекта, называется полиморфизмом.

Давайте представим, что нам в программе нужно описать пользователя, который может пользоваться любыми моделями телефона, чтобы позвонить другому пользователю. 

**Вот как можно это сделать:**

public class User {
private String name;

        public User(String name) {
            this.name = name;
                }
    
        public void callAnotherUser(int number, AbstractPhone phone){
    // вот он полиморфизм - использование в коде абстактного типа AbstractPhone phone!
    phone.call(number);
    }
    }
    }

**Теперь опишем различные модели телефонов. Одна из первых моделей телефонов:**

    public class ThomasEdisonPhone extends AbstractPhone {
    
    public ThomasEdisonPhone(int year) {
    super(year);
    }
    @Override
    public void call(int outputNumber) {
    System.out.println("Вращайте ручку");
    System.out.println("Сообщите номер абонента, сэр");
    }
    
        @Override
        public void ring(int inputNumber) {
            System.out.println("Телефон звонит");
        }
    }

**Обычный стационарный телефон:**

    public class Phone extends AbstractPhone {
    
        public Phone(int year) {
            super(year);
        }
    
        @Override
        public void call(int outputNumber) {
            System.out.println("Вызываю номер" + outputNumber);
        }
    
        @Override
        public void ring(int inputNumber) {
            System.out.println("Телефон звонит");
        }
    }

**И, наконец, крутой видеотелефон:**

    public class VideoPhone extends AbstractPhone {
    
        public VideoPhone(int year) {
            super(year);
        }
        @Override
        public void call(int outputNumber) {
            System.out.println("Подключаю видеоканал для абонента " + outputNumber );
        }
        @Override
        public void ring(int inputNumber) {
            System.out.println("У вас входящий видеовызов..." + inputNumber);
        }
    }

**Создадим объекты в методе main() и протестируем метод callAnotherUser:**

    AbstractPhone firstPhone = new ThomasEdisonPhone(1879);
    AbstractPhone phone = new Phone(1984);
    AbstractPhone videoPhone=new VideoPhone(2018);
    User user = new User("Андрей");
    user.callAnotherUser(224466,firstPhone);
    // Вращайте ручку
    //Сообщите номер абонента, сэр
    user.callAnotherUser(224466,phone);
    //Вызываю номер 224466
    user.callAnotherUser(224466,videoPhone);
    //Подключаю видеоканал для абонента 224466

Используя вызов одного и того же метода объекта user, мы получили различные результаты. Выбор конкретной реализации метода call внутри метода callAnotherUser производился динамически на основании конкретного типа вызывающего его объекта в процессе выполнения программы. В этом и заключается основное преимущество полиморфизма – выбор реализации в процессе выполнения программы.

В примерах классов телефонов, приведенных выше, мы использовали переопределение методов – прием, при котором изменяется реализация метода, определенная в базовом классе, без изменения сигнатуры метода. По сути это является заменой метода, и именно новый метод, определенный в подклассе, вызывается при выполнении программы.

Обычно, при переопределении метода, используется аннотация @Override, которая подсказывает компилятору о необходимости проверить сигнатуры переопределяемого и переопределяющего методов.

**В итоге, чтобы стиль вашей программы соответствовал концепции ООП и принципам ООП java следуйте следующим советам:**
* выделяйте главные характеристики объекта;
* выделяйте общие свойства и поведение и используйте наследование при создании объектов;
* используйте абстрактные типы для описания объектов;
* старайтесь всегда скрывать методы и поля, относящиеся к внутренней реализации класса.

### 2. Опишите процедуру инициализации полей класса и полей экземпляра класса. Когда инициализируются поля класса, а когда – поля экземпляров класса. Какие значения присваиваются полям по умолчанию? Где еще в классе полям могут быть присвоены начальные значения?

Как известно, в Java поля (fields) могут принадлежать классу или объекту. Поля, принадлежащие классу, являются статическими, а поля, принадлежащие объекту, - нестатическими. Статические поля доступны без создания объекта класса. Соответственно инициализироваться статические и нестатические поля должны в разное время: одни до создания объекта класса, а другие после.

**Типы инициализации полей объектов и классов**

**Существуют следующие методы инициализации полей:**

* Инициализация в месте объявления поля - Применяется, если инициализация может быть произведена коротким выражением и доступен контекст, необходимый для ее проведения
* Инициализационный блок - Применяется, если инициализационный код неудобно записывать одним выражением или же, например, нужна обработка проверяемых исключений. В случае объектов может применяться для инициализации полей объектов анонимных классов.
* Конструктор класса - Применяется, если для инициализации нужны параметры конструктора

**Инициализация статических полей в месте объявления**

**Начнем с примера:**

    class Integer {
    ...
    public static final int SIZE = 32;
    ...
    }

Здесь инициализируется статическое поле SIZE класса Integer. Сама инициализация произойдет во время загрузки класса. 

**В этом легко убедиться выполнив следующий код:**

    public class StaticInitializationTime {
    public static class C {
    static int i = value();
    static int value() {
    System.out.println("C.i initialized");
    return 1;
    }
    }
    
        public static void main(String[] args) throws ClassNotFoundException {
            System.out.println("Before class loading");
            Class.forName(C.class.getName());
            System.out.println("After class loading");
        }
    }

**В результате будет выведено:**

    Before class loading
    C.i initialized
    After class loading

**Инициализация в статическом блоке**

В некоторых случаях инициализацию неудобно проводить в месте объявления переменной. Например, если в результате выполнения инициализирующего выражения происходит проверяемое исключение. Или же, если инициализация производится путем выполнения кода, который не может быть представлен в виде выражения. Для таких случаев в Java предусмотрен специальный языковой элемент - инициализационный статический блок. 

**Покажем на примере:**

    static List<Character> alphabet;
    static {
    alphabet = new ArrayList<Character>();
    for (char c='a'; c<='z'; c++) alphabet.add(c);
    }

Переменная alphabet инициализируется в статическом блоке. Инициализация происходит во время загрузки класса аналогично как и в предыдущем примере.

Инициализация статических полей в месте объявления и статические блоки выполняются в порядке их объявления в классе. 

**Давайте выполним следующий код:**

    public class ClassFieldsInitOrder {
    static int i1 = initialize("i0");
    
        static int i2;
        static { i2 = initialize("i1"); }
    
        static int i3 = initialize("i2");
    
        static int i4;
        static { i4 = initialize("i4"); }
    
        static int initialize(String name) {
            System.out.println(name);
            return 0;
        }
    
        public static void main(String[] args) {}
    }

**На консоль будет выведено:**

    i0
    i1
    i2
    i4

**Инициализация полей объекта**

В отличии от полей класса, поля объекта инициализируются во время конструирования экземпляра класса. 

**В Java существует 3 типа такой инициализации:**

* инициализация в месте объявления
* инициализация в нестатическом блоке
* инициализация в конструкторе

**Инициализация полей объекта в месте объявления**

**Покажем на примере:**

    public class Blog {
    ...
    private List<Post> posts = new ArrayList<Post>
    ...
    }

Инициализация поля posts будет произведена во время конструирования объекта Blog.

**Инициализация полей объекта в нестатическом блоке**

Использование инициализационных блоков является альтернативой предыдущему способу инициализации. Данный тип инициализации может использоваться, если:

во время инициализации необходимо обработать проверяемое исключение
значение поля не удобно вычислять с помощью выражения (например, для этого нужен специально созданный класс или метод, который не хочется создавать только для этих целей)
необходимо инициализировать поле анонимного класса (в анонимном классе невозможно объявить конструктор)

**Пример обработки проверяемого исключения:**

    class Year2000Problem {
    Date start;
    {
    try { start = new SimpleDateFormat("dd.MM.yyyy").parse("01.01.2000"); }
    catch (ParseException impossible) {}
    }
    }

**Инициализация полей объекта в конструкторе**

Часто инициализацию полей объекта имеет смысл проводить только с учетом значений параметров конструктора. В таких случаях ее производят в самом конструкторе. 

**Пример:**

    class User {
    ...
    String login;
    
        User(String login) { this.login = login; }
        ...
    }
**Инициализация в конструкторе и наследование**

**Выполним следующий код:**

    public class InheritanceInitOrder {
    static class A {
    String a;
    A() {
    a = "a";
    System.out.println("a initialized");
    System.out.println("b=" + ((B)this).b);
    }
    }
    
        static class B extends A {
            String b;
            B() {
                b = "b";
                System.out.println("b initialized");
                System.out.println("b=" + b);
            }
        }
    
        public static void main(String[] args) throws ClassNotFoundException {
            new B();
        }
    }

В Java можно инициализировать переменную, если она является членом класса. 

**Существует четыре способа инициализации членов данных класса:**

* инициализация по умолчанию (неявная инициализация);
* явная инициализация начальными значениями (константными значениями);
* явная инициализация методами класса;
* инициализация с помощью конструкторов классов.


При объявлении переменной в некотором классе, этой переменной присваиваются значения по умолчанию. Ниже приведены значения по умолчанию, которые присваиваются переменным разных типов

    int      => 0
    boolean  => false
    double   => 0.0
    float    => 0.0
    char     => ' ' - нуль-символ
    long     => 0
    byte     => 0




### 3. Приведите правила, которым должен следовать компонент java-bean.

**Правила описания JavaBean**

* Класс должен иметь конструктор без параметров, с модификатором доступа public. Такой конструктор позволяет инструментам создать объект без дополнительных сложностей с параметрами.
* Свойства класса должны быть доступны через get, set и другие методы (так называемые методы доступа), которые должны подчиняться стандартному соглашению об именах. Это легко позволяет инструментам автоматически определять и обновлять содержание bean’ов. Многие инструменты даже имеют специализированные редакторы для различных типов свойств.
* Класс должен быть сериализуем. Это даёт возможность надёжно сохранять, хранить и восстанавливать состояние bean независимым от платформы и виртуальной машины способом.
* Класс должен иметь переопределенные методы equals(), hashCode() и toString().

Так как требования в основном изложены в виде соглашения, а не интерфейса, некоторые разработчики рассматривают JavaBeans, как Plain Old Java Objects, которые следуют определённым правилам именования.

### 4. Дайте определение перегрузке методов. Как вы думаете, чем удобна перегрузка методов? Укажите, какие методы могут перегружаться, и какими методами они могут быть перегружены? Можно ли перегрузить методы в базовом и производном классах? Можно ли private метод базового класса перегрузить public методов производного? Можно ли перегрузить конструкторы, и можно ли при перегрузке конструкторов менять атрибуты доступа у конструкторов?
Java позволяет создавать несколько методов с одинаковыми именами, но разными сигнатурами. Создание метода с тем же именем, но с другим набором параметров называется перегрузкой. Какой из перегруженных методов должен выполняться при вызове, Java определяет на основе фактических параметров.

Перегрузка методов является одним из способов реализации принципа полиморфизма в Java.
Для того чтобы перегрузить метод, достаточно объявить его новый вариант, отлича¬ющийся от уже существующих, а все остальное сделает компилятор. Нужно лишь со¬блюсти одно условие: тип и/или число параметров в каждом из перегружаемых методов должны быть разными.
Одного лишь различия в типах возвращаемых значений для этой цели недостаточно. (Информации о возвращаемом типе не всегда будет хватать Java для принятия решения о том, какой именно метод должен использоваться.)

Конечно, пе¬регружаемые методы могут иметь разные возвращаемые типы, но при вызове метода выполняется лишь тот его вариант, в котором параметры соответствуют передаваемым аргументам.
Ниже приведен простой пример программы, демонстрирующий перегрузку методов.
```
class Overload {
     // Первая версия
    void ovlDemo() {
        System.out.println("Без параметров");
    }
     // Перезагрузка метода ovlDemo для одного параметра типа int
    // Вторая версия
    void ovlDemo(int a) {
        System.out.println("Один параметр: " + a);
    }
     // Перезагрузка метода ovlDemo для двух параметров типа int
    // Третья версия
    int ovlDemo(int a, int b) {
        System.out.println("Два параметра: " + a + " " + b);
        return a + b;
    }
     // Перезагрузка метода ovlDemo для двух параметров типа double
    // Четвертая версия
    double ovlDemo(double a, double b) {
        System.out.println("Два параметра типа double: " + a + " " + b);
        return a + b;
    }
 }
 
class OverloadDemo {
    public static void main(String args[]) {
        Overload ob = new Overload();
        int resI;
        double resD;
     // Поочередно вызвать все версии метода ovlDemo()
    ob.ovlDemo();
    System.out.println();
        ob.ovlDemo(2);
    System.out.println();
        resI = ob.ovlDemo(4, 6);
    System.out.println("Результат вызова ob.ovlDemo(4, 6): " + resI);
    System.out.println();
     resD = ob.ovlDemo(1.1, 2.32);
    System.out.println("Результат вызова ob.ovlDemo(1.1, 2.32): " + resD);
     }
 }
```
Как видите, метод ovlDemo() перегружается четырежды. В первой его версии па¬раметры не предусмотрены, во второй - определен один целочисленный параметр, в третьей - два целочисленных параметра, в четвертой - два параметра типа double.
Обратите внимание на то, что первые два варианта метода ovlDemo() имеют тип void, а два другие возвращают значение. Тип возвращаемого значения не учитывается при перегрузке методов. Следовательно, попытка определить два варианта метода ovlDemo() так, как показано ниже, приводит к ошибке.

Возвращаемое значение нельзя использовать
для различения перезагружаемых методов
```*/
void ovlDemo(int a) {
    System.out.println("One parameter: " + a);
}
 ```
/* Ошибка! Невозможно существование двух версий
перезагруженного метода ovlDemo(int), отличающихся
лишь типом возвращаемого значения.
*/
 ```
int ovlDemo(int a) {
    System.out.println("Один параметр: " + a);
    return a * a * a;
}
```
Как поясняется в комментариях к приведенному выше фрагменту кода, отличия воз¬вращаемых типов недостаточно для перегрузки методов.
Как мы знаем, в Java применяется автоматическое приведение типов. Это приведение распространяется и на типы параметров перегружаемых методов. В качестве примера рассмотрим следующий фрагмент кода.

Автоматическое преобразование типов
может влиять на выбор перезагружаемого метода.
```*/
 
class Overload2 {
    void f(int x) {
        System.out.println("Внутри f(int): " + x);
    }
 
    void f(double x) {
        System.out.println("Внутри f(double): " + x);
    }
}
 
class TypeConv {
    public static void main(String args[]) {
 
        Overload2 ob = new Overload2();
        int i = 10;
        double d = 10.1;
        byte b = 99;
        short s = 10;
        float f = 11.5F;
 
        ob.f(i); // вызов метода ob.f(int)
        ob.f(d); // вызов метода ob.f(double)
        ob.f(b); // вызов метода ob.f(int) с преобразованием типов
        ob.f(s); // вызов метода ob.f(int) с преобразованием типов
        ob.f(f); // вызов метода ob.f(double) с преобразованием типов
     }
}
```
В данном примере определены только два варианта метода f(): один принимает параметр типа int, а второй - параметр типа double.
Но передать методу f() можно также значение типа byte, short и float. Значения типа byte и short исполняющая система Java автоматически преобразует в тип int. В результате будет вызван вариант метода f(int). А если параметр имеет значение типа float, то оно преобразуется в тип doube, и далее вызывается вариант метода f(double).
Важно понимать, что автоматическое преобразование типов выполняется лишь в от¬сутствие прямого соответствия типов параметра и аргумента. В качестве примера ниже представлена другая версия предыдущей программы, в которой добавлен вариант метода f() с параметром типа byte.
```
class Overload3 {
    void f(byte x) {
        System.out.println("Внутри f(byte): " + x);
    }
     void f(int x) {
        System.out.println("Внутри f(int): " + x);
    }
     void f(double x) {
        System.out.println("Внутри f(double): " + x);
    }
 }
    
 class TypeConv {
    public static void main(String args[]) {
 
        Overload3 ob = new Overload3();
        int i = 10;
        double d = 10.1;
        byte b = 99;
        short s = 10;
        float f = 11.5F;
 
        ob.f(i); // вызов метода ob.f(int)
        ob.f(d); // вызов метода ob.f(double)
        ob.f(b); // вызов метода ob.f(byte) без преобразования типов
        ob.f(s); // вызов метода ob.f(int) с преобразованием типов
        ob.f(f); // вызов метода ob.f(double) с преобразованием типов
 
    }
}
```
Поскольку в данной программе предусмотрена версия метода f(), которая принима¬ет параметр типа byte, то при вызове этого метода с аргументом типа byte выполняется вызов f (byte), и автоматического преобразования типа byte в тип int не происходит.

Перегрузка методов поддерживает полиморфизм, поскольку она является одним из способов реализации парадигмы "один интерфейс - множество методов". Для того чтобы стало понятнее, как и для чего это делается, необходимо принять во внимание следующее соображение: в языках программирования, не поддерживающих перегрузку методов, каждый метод должен иметь уникальное имя.

Но в ряде случаев требуется вы¬полнять одну и ту же последовательность операций над разными типами данных. В качестве примера рассмотрим функцию, определяющую абсолютное значение.
В языках, не поддерживающих перегрузку методов, приходится создавать несколько вариантов данной функции с именами, отличающимися хотя бы одним символом.
Например,в языке С функция abs() возвращает абсолютное значение числа типа int, функция labs() - абсолютное значение числа типа long, а функция fabs() - абсолютное зна¬чение числа с плавающей точкой.

Объясняется это тем, что в С не поддерживается пе¬регрузка, и поэтому каждая из функций должна обладать своим собственным именем,несмотря на то что все они выполняют одинаковые действия. Это приводит к нео¬правданному усложнению процесса написания программ.
Разработчику приходится не только представлять себе действия, выполняемые функциями, но и помнить все три их имени. Такая ситуация не возникает в Java, потому что все методы, вычисляющие абсо¬лютное значение, имеют одно и то же имя.
В стандартной библиотеке Java для вычисле¬ния абсолютного значения предусмотрен метод abs(). Его перегрузка осуществляется в классе Math для обработки значений всех числовых типов.
Решение о том, какой имен¬но вариант метода abs() должен быть вызван, исполняющая система Java принимает, исходя из типа аргумента.
Главная ценность перегрузки заключается в том, что она обеспечивает доступ к груп¬пе родственных методов по общему имени. Следовательно, имя abs обозначает общее выполняемое действие, а компилятор сам выбирает конкретный вариант метода по об¬стоятельствам.
Благодаря полиморфизму несколько имен сводятся к одному. Несмотря на всю простоту рассматриваемого здесь примера, продемонстрированный в нем прин¬цип полиморфизма можно расширить, чтобы выяснить, каким образом перегрузка по¬могает справляться с более сложными ситуациями в программировании.

Когда метод перегружается, каждая его версия может выполнять какое угодно дей¬ствие. Для установления взаимосвязи перегружаемых методов не существует какого-то твердого правила, но с точки зрения правильного стиля программирования перегрузка методов подразумевает подобную взаимосвязь. Следовательно, использовать одно и тоже имя для несвязанных друг с другом методов не следует, хотя это и возможно.

Напри¬мер, имя sqr можно было бы выбрать для методов, возвращающих квадрат и квадрат¬ный корень числа с плавающей точкой. Но ведь это принципиально разные операции.
Такое применение перегрузки методов противоречит ее первоначальному назначению.На практике перегружать следует только тесно связанные операции.

Стоит отметить, что, программисты на Java часто употребляют термин сигнатура. Что это такое?
Применительно к языку Java сигнатура обозначает имя метода и список его пара¬метров. При перегрузке методов действует следующее правило: никакие два ме¬тода из одного класса не могут иметь одинаковые сигнатуры.

Следует, однако, иметь в виду, что сигнатура не включает в себя тип возвращаемого значения, поскольку он не используется в Java при принятии решения о перегрузке.
Статические методы могут перегружаться нестатическими и наоборот – без ограничений
Переопределять можно любые видимые в производном классе не финальные методы. Исключение - переопределение конструкторов базового класс невозможно!

В производном классе разрешается перегружать (overload) любые видимые методы. При наследовании, Вы берете существующий класс и создаете специальную его версию.
**Конструктор** – это схожая c методом структура, назначение которой состоит в создании экземпляра класса.

**Характеристики конструктора:**
Имя конструктора должно совпадать с именем класса (по договоренности, первая буква — заглавная, обычно имя существительное);

Конструктор имеется в любом классе. Даже если вы его не написали, компилятор Java сам создаст конструктор по умолчанию (default constructor), который будет пустым и не делает ничего, кроме вызова конструктора суперкласса.

Конструктор похож на метод, но не является методом, он даже не считается членом класса. Поэтому его нельзя наследовать или переопределить в подклассе;

Конструкторы не наследуются;

Конструкторов может быть несколько в классе. В этом случае конструкторы называют перегруженными;

Если в классе не описан конструктор, компилятор автоматически добавляет в код конструктор без параметров;

Конструктор не имеет возвращаемого типа, им не может быть даже тип void, если возвращается тип void, то это уже не конструктор а метод, несмотря на совпадение с именем класса.

В конструкторе допускается оператор return, но только пустой, без всякого возвращаемого значения;

В конструкторе допускается применение модификаторов доступа, можно задать один из модификаторов: public, protected, private или без модификатора.

Конструктор не может иметь модификаторов abstract, final, native, static или synchronized;

Ключевое слово this cсылается на другой конструктор в этом же классе. Если используется, то обращение должно к нему быть первой строкой конструктора;

Ключевое слово super вызывает конструктор родительского класса. Если используется, должно обращение к нему быть первой строкой конструктора;

Если конструктор не делает вызов конструктора super класса-предка (с аргументами или без аргументов), компилятор автоматически добавляет код вызова конструктора класса-предка без аргументов;

**Конструктор по умолчанию**
Конструктор имеется в любом классе. Даже если вы его не написали, компилятор Java сам создаст конструктор по умолчанию (default constructor). Этот конструктор пустой и не делает ничего, кроме вызова конструктора суперкласса.
Конструкторы одного класса могут иметь одинаковое имя и различную сигнатуру. Такое свойство называется совмещением или перегрузкой(overloading). Если класс имеет несколько конструкторов, то присутствует перегрузка конструкторов.

### 5. Объясните, что такое раннее и позднее связывание? Перегрузка – это раннее или позднее связывание? Объясните правила, которым следует компилятор при разрешении перегрузки; в том числе, если методы перегружаются примитивными типами, между которыми возможно неявное приведение или ссылочными типами, состоящими в иерархической связи.

Чтобы выяснить, в чем состоит различие между ранним (статическим) и поздним (динамическим) связыванием в Java, нужно сначала понять, что такое это самое связывание. Связывание означает наличие связи между ссылкой и кодом. Например, переменная, на которую вы ссылаетесь, привязана к коду, в котором она определена. Аналогично, вызываемый метод привязан к месту в коде, где он определен.

Существует два типа связывания методов в языке Java: ранее связывание (его ещё называют статическим) и позднее (соответственно, динамическое) связывание. Вызов метода в Java означает, что этот метод привязывается к конкретному коду или в момент компиляции, или во время выполнения, при запуске программы и создании объектов. Можно понять из названия, статическое связывание носит более статический характер, так как происходит во время компиляции, то есть код «знает», какой метод вызывать после компиляции исходного кода на Java в файлы классов. А поскольку это относится к ранней стадии жизненного цикла программы, то называется также ранним связыванием (early binding). С другой стороны, динамическое связывание происходит во время выполнения, после запуска программы виртуальной машиной Java. В этом случае то, какой метод вызвать, определяется конкретным объектом, так что в момент компиляции информация недоступна, ведь объекты создаются во время выполнения. А поскольку это происходит на поздней стадии жизненного цикла программы, то называется в языке Java поздним связыванием (late binding).

Итак, фундаментальное различие между статическим и динамическим связыванием в Java состоит в том, что первое происходит рано, во время компиляции на основе типа ссылочной переменной, а второе – позднее, во время выполнения, с использованием конкретных объектов.
Существует множество различий статического и динамического связывания в языке Java, но важнейшее – то, как их использует JVM. Задумывались ли вы когда-нибудь, каким образом JVM решает, какой метод вызвать, если в области видимости содержится более одного метода с одним именем? Если вы когда-либо использовали перегрузку или переопределение методов, то знаете, что в Java может быть несколько методов с одним именем. В случае с Java виртуальная машина JVM использует как статическое, так и динамическое связывание для выбора нужного метода.
Пример статического и динамического связывания в Java

В этой программе вы увидите, что привязка виртуальных методов не происходит во время компиляции при помощи статического связывания, поскольку в этом случае вызывался бы метод из суперкласса, как происходит со статическими методами, которые связываются рано. Если будет вызван метод из подкласса, то для связывания функции использовался конкретный объект во время выполнения, а, следовательно, для связывания виртуальных функций используется динамическое связывание.
```
public class Main {
  public static void main(String[] args) {
    // Пример статического и динамического связывания в Java
    Insurance current = new CarInsurance();
    // Динамическое связывание на основе объекта
    int premium = current.premium();
    // Статическое связывание на основе класса
    String category = current.category();

    System.out.println("premium : " + premium);
    System.out.println("category : " + category);
  }
}
class Insurance{
  public static final int LOW = 100;
  public int premium(){
    return LOW;
  }
  public static String category(){
    return "Insurance";
  }
}
class CarInsurance extends Insurance{
  public static final int HIGH = 200;
  public int premium(){
    return HIGH;
  }
  public static String category(){
    return "Car Insurance";
  }
}
Результаты выполнения:
premium : 200
category : Insurance
```
Как вы видите, вызов метода premium() привел к выполнению метода из подкласса, в то время как вызов метода category() привел к выполнению метода суперкласса. Это происходит из-за того, что premium() – виртуальный метод, который разрешается при помощи позднего связывания, в то время как category() – статический метод, который разрешается при помощи статического связывания во время компиляции по имени класса.


### 6. Объясните, как вы понимаете, что такое неявная ссылка this? В каких методах эта ссылка присутствует, а в каких – нет, и почему?

Как правило, применять this нужно в двух случаях:

Когда у переменной экземпляра класса и переменной метода/конструктора одинаковые имена;
Когда нужно вызвать конструктор одного типа (например, конструктор по умолчанию или параметризированный) из другого. Это еще называется явным вызовом конструктора.
Вот и все, на самом деле не так много, — всего два случая, когда применяется это страшное ключевое слово. Теперь давайте рассмотрим эти две ситуации на примерах. https://javarush.ru/groups/posts/608-kljuchevoe-slovo-this-v-primerakh

### 7. Что такое финальные поля, какие поля можно объявить со спецификатором final? Где можно инициализировать финальные поля?

В java есть ключевое слово – final. Оно может применяться к классам, методам, переменным (в том числе аргументам методов).

Для класса это означает, что класс не сможет иметь подклассов, т.е. запрещено наследование. Это полезно при создании immutable (неизменяемых) объектов, например, класс String объявлен, как final.

public final class String{
}
class SubString extends String{ //Ошибка компиляции
}
Следует также отметить, что к абстрактным классам (с ключевым словом abstract), нельзя применить модификатор final, т.к. это взаимоисключающие понятия. Для метода final означает, что он не может быть переопределен в подклассах. Это полезно, когда мы хотим, чтобы исходную реализацию нельзя было переопределить.
public class SuperClass{
public final void printReport(){
System.out.println("Report");
}
}
class SubClass extends SuperClass{
public void printReport(){  //Ошибка компиляции
System.out.println("MyReport");
}
}
Для переменных примитивного типа это означает, что однажды присвоенное значение не может быть изменено. Для ссылочных переменных это означает, что после присвоения объекта, нельзя изменить ссылку на данный объект. Это важно! Ссылку изменить нельзя, но состояние объекта изменять можно.

С java 8 появилось понятие — effectively final. Применяется оно только к переменным (в том числе аргументам методов). Суть в том, что не смотря на явное отсутствие ключевого слова final, значение переменной не изменяется после инициализации. Другими словами, к такой переменной можно подставить слово final без ошибки компиляции. effectively final переменные могут быть использованы внутри локальных классов (Local Inner Classes), анонимных классов (Anonymous Inner Classes), стримах (Stream API).

public void someMethod(){
// В примере ниже и a и b - effectively final, тк значения устанавливаютcя однажды:
int a = 1;
int b;
if (a == 2) b = 3;
else b = 4;
// с НЕ является effectively final, т.к. значение изменяется
int c = 10;
c++;

    Stream.of(1, 2).forEach(s-> System.out.println(s + a)); //Ок
    Stream.of(1, 2).forEach(s-> System.out.println(s + c)); //Ошибка компиляции
}

### 8. Что такое статические поля, статические финальные поля и статические методы. К чему имеют доступ статические методы? Можно ли перегрузить и переопределить статические методы? Наследуются ли статические методы?

А то, что если переменная не статическая, то у каждого нового объекта данного класса будет своё значение этой переменной, меняя которое мы меняем его исключительно в одном объекте: Например, у нас есть класс Car с нестатической переменной:

public class Car {
int km;
}
Тогда в main:
Car orangeCar = new Car();
orangeCar.km = 100;

Car blueCar = new Car();
blueCar.km = 85;

System.out.println("Orange car - " + orangeCar.km);
System.out.println("Blue car - " + blueCar.km);
Статический блок

Есть два блока инициализации — обычный и статический. Блок предназначен для инициализации внутренних переменных. Если блок обычный, то им инициализируют внутренние переменные объекта, если же не статический, соответственно, им задают статические переменные (то есть переменные класса).

Пример класса с нестатическим блоком инициализации:

public class Car {
static int km;

static {
km = 150;
}
}
Статический метод

Статические методы отличаются от обычных тем, что они также привязаны к классу, а не к объекту. Важным свойством статического метода является то, что он может обратиться только к статическим переменным/методам. В качестве примера давайте рассмотрим класс, который у нас будет неким счётчиком, ведущим учет вызовов метода:

public class Counter {
static int count;

public static void invokeCounter() {
count++;
System.out.println("Текущее значение счётчика - " + count);
}
}
Статический класс в Java

Статическим классом может быть только внутренний класс. Опять же, этот класс привязан к внешнему классу, и если внешний наследуется другим классом, то этот не будет наследован. При этом данный класс можно наследовать, как и он может наследоваться от любого другого класса и имплементировать интерфейс. По сути статический вложенный класс ничем не отличается от любого другого внутреннего класса за исключением того, что его объект не содержит ссылку на создавший его объект внешнего класса. Тем не менее, благодаря этому статический класс наиболее похож на обычный не вложенный, ведь единственное различие состоит в том, что он упакован в другой класс. В некоторых случаях для нас это преимущество, так как с него у нас есть доступ к приватным статическим переменным внешнего класса.

Пример вложенного статического класса:

public class Vehicle {

public static class Car {
public int km;
}
}
Для использования статических методов/переменных/класса нам не нужно создавать объект данного класса. Конечно, следует учитывать модификаторы доступа. Например, поля private доступны только внутри класса, в котором они объявлены. Поля protected доступны всем классам внутри пакета (package), а также всем классам-наследникам вне пакета. Для более подробной информации ознакомьтесь со статьей “private vs protected vs public”. Предположим, существует статический метод increment() в классе Counter, задачей которого является инкрементирование счётчика count. Для вызова данного метода можно использовать обращение вида Counter.increment(). Нет необходимости создавать экземпляр класса Counter для доступа к статическому полю или методу. Это фундаментальное отличие между статическими и НЕ статическими объектами (членами класса). Еще раз напомню, что статические члены класса напрямую принадлежат классу, а не его экземпляру. То есть, значение статической переменной count будет одинаковое для всех объектов типа Counter.

В этом разделе мы рассмотрим основные моменты использования статических методов, полей и классов. Начнём с переменных.

Вы НЕ можете получить доступ к НЕ статическим членам класса, внутри статического контекста, как вариант, метода или блока. Результатом компиляции приведенного ниже кода будет ошибка:
public class Counter{
private int count;
public static void main(String args[]){
System.out.println(count); //compile time error
}}
Это одна из наиболее распространённых ошибок допускаемых программистами Java, особенно новичками. Так как метод main статичный, а переменная count нет, в этом случае метод println, внутри метода main выбросит “Compile time error”.

В отличие от локальных переменных, статические поля и методы НЕ потокобезопасны (Thread-safe) в Java. На практике это одна из наиболее частых причин возникновения проблем связанных с безопасностью мультипоточного программирования. Учитывая что каждый экземпляр класса имеет одну и ту же копию статической переменной, то такая переменная нуждается в защите — «залочивании» классом. Поэтому при использовании статических переменных, убедитесь, что они должным образом синхронизированы (synchronized), во избежание проблем, например таких как «состояние гонки» (race condition).

Статические методы имеют преимущество в применении, т.к. отсутствует необходимость каждый раз создавать новый объект для доступа к таким методам. Статический метод можно вызвать, используя тип класса, в котором эти методы описаны. Именно поэтому, подобные методы как нельзя лучше подходят в качестве методов-фабрик (factory), и методов-утилит (utility). Класс java.lang.Math — замечательный пример, в котором почти все методы статичны, по этой же причине классы-утилиты в Java финализированы (final).

Другим важным моментом является то, что вы НЕ можете переопределять (Override) статические методы. Если вы объявите такой же метод в классе-наследнике (subclass), т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса (superclass) вместо переопределения. Это явление известно как сокрытие методов (hiding methods). Это означает, что при обращении к статическому методу, который объявлен как в родительском, так и в дочернем классе, во время компиляции всегда будет вызван метод исходя из типа переменной. В отличие от переопределения, такие методы не будут выполнены во время работы программы.

Рассмотрим пример:

class Vehicle{
public static void  kmToMiles(int km){
System.out.println("Внутри родительского класса/статического метода");
} }

class Car extends Vehicle{
public static void  kmToMiles(int km){
System.out.println("Внутри дочернего класса/статического метода ");
} }

public class Demo{
public static void main(String args[]){
Vehicle v = new Car();
v.kmToMiles(10);
}}
Объявить статическим также можно и класс, за исключением классов верхнего уровня. Такие классы известны как «вложенные статические классы» (nested static class). Они бывают полезными для представления улучшенных связей. Яркий пример вложенного статического класса — HashMap.Entry, который предоставляет структуру данных внутри HashMap. Стоит заметить, также как и любой другой внутренний класс, вложенные классы находятся в отдельном файле .class. Таким образом, если вы объявили пять вложенных классов в вашем главном классе, у вас будет 6 файлов с расширением .class. Ещё одним примером использования является объявление собственного компаратора (Comparator), например компаратор по возрасту (AgeComparator) в классе сотрудники (Employee).

Модификатор static также может быть объявлен в статичном блоке, более известным как «Статический блок инициализации» (Static initializer block), который будет выполнен во время загрузки класса. Если вы не объявите такой блок, то Java соберёт все статические поля в один список и выполнит его во время загрузки класса. Однако, статичный блок НЕ может пробросить перехваченные исключения, но может выбросить не перехваченные. В таком случае возникнет «Exception Initializer Error». На практике, любое исключение возникшее во время выполнения и инициализации статических полей, будет завёрнуто Java в эту ошибку. Это также самая частая причина ошибки «No Class Def Found Error», т.к. класс не находился в памяти во время обращения к нему.

Полезно знать, что статические методы связываются во время компиляции, в отличие от связывания виртуальных или не статических методов, которые связываются во время исполнения на реальном объекте. Следовательно, статические методы не могут быть переопределены в Java, т.к. полиморфизм во время выполнения не распространяется на них. Это важное ограничение, которое необходимо учитывать, объявляя метод статическим. В этом есть смысл, только тогда, когда нет возможности или необходимости переопределения такого метода классами-наследниками. Методы-фабрики и методы-утилиты хорошие образцы применения модификатора static. Джошуа Блох выделил несколько преимуществ использования статичного метода-фабрики перед конструктором, в книге «Effective Java», которая является обязательной для прочтения каждым программистом данного языка.

Важным свойством статического блока является инициализация. Статические поля или переменные инициализируются после загрузки класса в память. Порядок инициализации сверху вниз, в том же порядке, в каком они описаны в исходном файле Java класса. Поскольку статические поля инициализируются на потокобезопасный манер, это свойство также используется для реализации паттерна Singleton. Если вы не используется список Enum как Singleton, по тем или иным причинам, то для вас есть хорошая альтернатива. Но в таком случае необходимо учесть, что это не «ленивая» инициализация. Это означает, что статическое поле будет проинициализировано ещё ДО того как кто-нибудь об этом «попросит». Если объект ресурсоёмкий или редко используется, то инициализация его в статическом блоке сыграет не в вашу пользу.

Во время сериализации, также как и transient переменные, статические поля не сериализуются. Действительно, если сохранить любые данные в статическом поле, то после десериализации новый объект будет содержать его первичное (по-умолчанию) значение, например, если статическим полем была переменная типа int, то её значение после десериализации будет равно нулю, если типа float – 0.0, если типа Object – null. Честно говоря, это один из наиболее часто задаваемых вопросов касательно сериализации на собеседованиях по Java. Не храните наиболее важные данные об объекте в статическом поле!

И напоследок, поговорим о static import. Данный модификатор имеет много общего со стандартным оператором import, но в отличие от него позволяет импортировать один или все статические члены класса. При импортировании статических методов, к ним можно обращаться как будто они определены в этом же классе, аналогично при импортировании полей, мы можем получить доступ без указания имени класса. Данная возможность появилась в Java версии 1.5, и при должном использовании улучшает читабельность кода. Наиболее часто данная конструкция встречается в тестах JUnit, т.к. почти все разработчики тестов используют static import для assert методов, например assertEquals() и для их перегруженных дубликатов

### 9. Что такое логические и статические блоки инициализации? Сколько их может быть в классе, в каком порядке они могут быть размещены и в каком порядке вызываются?

**Переменные**

Переменные (variables) - это контейнеры, которые хранят какие-либо данные. Посмотрим официальный Tutorial от Oracle : Declaring Member Variables. Согласно данному Tutorial, существует несколько типов переменных:

•	Поля (fields) : переменные, объявленные в классе;
•	Локальные переменные (local variables) : переменные в методе или в блоке кода;
•	Параметры (parameters) : переменные в объявлении метода (в сигнатуре).

Все переменные должны иметь тип переменной и название переменной.

Тип переменной показывает, какие данные представляет данная переменная (т.е. какие данные может хранить). Как мы знаем, тип переменной может быть примитивным (primitives primitives) или объектным, не примитивными (Non-primitive). При объектных переменных их тип описывается определённым классом.

Название переменной должно быть с маленькой буквы, в camel case. Подробнее про именование можно прочитать в "Variables:Naming".

Так же если переменная уровня класса, т.е. является полем класса, то для неё может указываться модификатор доступа. Подробнее см. Controlling Access to Members of a Class.

**Объявление переменной (Declaration)**

Итак, мы вспомнили, что такое переменная. Для того, чтобы с переменной начать работать нужно её объявить. Для начала, разберёмся с локальной переменной. Вместо IDE для удобства воспользуемся онлайн решением от tutorialspoint: Online IDE. Выполним в их online IDE вот такую простенькую программку:
```
public class HelloWorld{
    public static void main(String []args){
        int number;
        System.out.println(number);
    }
}
```
Итак, как видно, мы объявили локальную переменную с именем number и типом int. Нажимаем кнопку «Execute» и получаем ошибку:
```
HelloWorld.java:5: error: variable number might not have been initialized
        System.out.println(number);
  ```      
Что же произошло? Мы объявили переменную, но значение её не инициализировали. Стоит заметить, что ошибка эта произошла не в момент выполнения (т.е. не в Runtime), а в момент компиляции. Умный компилятор проверил, будет ли локальная переменная инициализирована до обращения к ней или нет. Поэтому, из этого следует следующие утверждения:

Обращение к локальным переменным должно быть выполнено только после того, как они будут инициализированы;

Локальные переменные не имеют значений по умолчанию;

Проверка значений локальных переменных выполняется в момент компиляции.

Итак, нам говорят, что переменная должна быть проинициализирована. Инициализация переменной – присвоение переменной значения. Давайте тогда разбираться, что это и почему.

**Инициализация локальной переменной**

Инициализация переменных одна из самых мудрёных тем в Java, т.к. очень тесно связана с работой с памятью, с реализацией JVM, спецификацией JVM и другими не менее страшными и хитрыми вещами. Но можно попробовать разобраться хоть в какой-то мере. Пойдём от простого к сложному. Чтобы инициализировать переменную воспользуемся оператором присваивания и изменим строчку в нашем прошлом коде:
```
int number = 2;
```
В таком варианте ошибок не будет и на экран выведется значение. Что же происходит в этом случае? Давайте попробуем порассуждать. Если мы хотим присвоить переменной какое-то значение, значит мы хотим, чтобы эта переменная хранила значение. Получается, что значение где-то должно храниться, но где? На диске? Но это очень медленно и может на нас накладывать ограничения. Получается, единственное, где мы можем быстро и эффективно хранить данные «здесь и сейчас» это память. Значит, нам нужно выделить в памяти какое-то место. Так и есть. При инициализации переменной под неё будет выделено место в памяти, отведённой java процессу, в рамках которого будет выполняться наша программа. Память, выделяемая java процессу, разделена на несколько областей или зон. В какой из них будет выделено место зависит от того, какого типа была объявлена переменная. Память разделяется на следующие разделы: Heap, Stack и Non-Heap. Начнём со стэковой памяти. Stack переводится как стопка (например, стопка книг). Представляет собой LIFO структуру данных (Last In, First Out). То есть как стопка книг. Когда мы добавляем в неё книги – мы кладём их сверху, а когда забираем – берём верхнюю (т.е. ту, которая добавлена самой последней). Итак, мы запускаем нашу программу. Как мы знаем, Java программу выполняет JVM, то есть виртуальная Java машина. JVM должна знать то, откуда должно начаться выполнение программы. Для этого мы объявляем main метод, который называется «точкой входа». Для выполнения в JVM создаётся основной поток (Thread). При создании потока ему выделяется свой стэк в памяти. Этот стэк состоит из фрэймов. При выполнении каждого нового метода в потоке под него будет выделен новый фрэйм и добавлен на вершину стэка (как новая книжка в стопке книг). Этот фрэйм будет содержит ссылки на объекты и примитивные типы. Да да, наш int будет храниться в стэке, т.к. int это примитивный тип. Прежде чем выделить фрэйм JVM должна понимать, что туда сохранять. Именно по этой причине мы получим ошибку «variable might not have been initialized», ведь если она не инициализирована, то JVM не сможет нам подготовить стэк. Поэтому при компиляции программы умный компилятор поможет нам не допустить ошибку и не сломать всё. (!) Для наглядности советую супер-пупер статью: "Java Stack and Heap: Java Memory Allocation Tutorial".

После завершения выполнения метода из стэка потока будут удаляться фрэймы, выделенные под эти методы, а вместе с ними и очищаться память, выделенная под этот фрэйм со всеми данными.
Инициализация локальных объектных переменных

Давайте опять изменим наш код на чуть более хитрый:
```
public class HelloWorld{
    private int number = 2;
    public static void main(String []args){
        HelloWorld object = new HelloWorld();
        System.out.println(object.number);
    }
}
```
Что же тут будет происходить? Давайте ещё раз рассуждать. JVM узнает о том, откуда ей выполнять программу, т.е. она видит main метод. Она создаёт поток, под него выделяет память (потоку ведь надо где-то хранить данные, которые нужны для выполнения). В этом потоке выделяется фрэйм под метод main. Далее мы создаём объект HelloWorld. Этот объект уже создаётся не в стэке, а в хипе. Потому что object у нас не примитивный тип, а объектный. А в стэке будет храниться только ссылка на объект в хипе (мы ведь как-то должны обращаться к этому объекту). Далее в стэке метода main будут выделены фрэймы для выполнения метода println. После выполнения метода main будут уничтожены все фрэймы. При уничтожении фрэйма будут уничтожены все данные. Объект object не будет уничтожен сразу. Сначала на него будет уничтожена ссылка и таким образом на объект object больше никто ссылаться не будет и доступа больше к этому объекту в памяти будет не получить. Умная JVM имеет свой механизм для такого – сборщик мусора (garbage collector или сокращённо GC). Он то и удаляет из памяти такие объекты, на которые больше никто не ссылается. Данный процесс опять же был описан в ссылке, что была приведена выше. Там даже видео есть с объяснением.

**Инициализация полей**

Инициализация полей, указанных в классе происходит особым образом в зависимости от того, является ли поле статическим или нет. Если у поля стоит ключевое слово static, то данное поле относится к самому классу, а не слово static не указано, то данное поле относится к экземпляру класса. Давайте рассмотрим это на примере:

В данном примере, инициализация полей происходит в разное время. Поле number будет инициализировано после того, как будет создан объект object класса HelloWorld. А вот поле count будет инициализировано тогда, когда класс будет загружен виртуальной Java машиной. Загрузка классов – это отдельная тема, поэтому не будем сюда примешивать её. Просто стоит знать, что статические переменные инициализируются тогда, когда о классе становится известно при выполнении. Тут важнее другое и Вы уже это заметили. Мы нигде не указали значения, а оно работает. И действительно. Переменные, которые являются полями, если для них не указано значение, то они инициализируются значением по умолчанию. Для числовых значением это 0 или 0.0 для чисел с плавающей точкой. Для boolean это false. А для всех переменных объектных типов значение будет null (об этом мы ещё поговорим). Казалось бы, а почему так? А потому, что объекты создаются в Heap (в куче). Работа с данной областью выполняется в Runtime. И мы в runtime можем инициализировать эти переменные, в отличии от стэка, память под который должна быть подготовлена ещё до выполнения. Так устроена работа с памятью в Java. Но есть тут и ещё одна особенность. В этом маленьком кусочке затрагиваются разные уголки памяти. Как мы помним, в Stack памяти под метод main выделяется фрэйм. В этом фрэйме хранится ссылка (reference) на объект в Heap памяти. Но где тогда хранится count? Как мы помним, эта переменная инициализируется сразу, до создания объекта в хипе. Вот тут действительно хитрый вопрос. До Java 8 существовала область памяти, называемая PERMGEN. Начиная с Java 8 эта область претерпела изменения и называется METASPACE. По сути, статические переменные являются частью описания класса, т.е. его метаданными. Поэтому, логично, что хранится в хранилище метаданных, METASPACE. MetaSpace относится к той самой Non-Heap области памяти, является её частью. Важно ещё учитывать то, что учитывается порядок, в котором объявлены переменные. Например, в этом коде ошибка:
```
public class HelloWorld{

    private static int b = a;
    private static int a = 1;

    public static void main(String []args){
        System.out.println(b);
    }
}
```
**Блоки инициализации**

Виды блоков инициализации
Существует всего два типа блоков:
нестатический (instance initializer)
статический (class initializer)

статический блок используется для инициализации статических переменных, а "обычный"  - для всех остальных.


Рассматривая инициализацию переменных грех не рассмотреть блоки инициализации. Выглядит это следующим образом:
public class HelloWorld{
```
    static {
        System.out.println("static block");
    }
    {
        System.out.println("block");
    }
    public HelloWorld () {
        System.out.println("Constructor");
    }
    public static void main(String []args){
        HelloWorld obj = new HelloWorld();
    }
}
```
Порядок вывода будет: static block, block, Constructor. Как мы видим, блоки инициализации выполняются раньше, чем конструктор. И иногда это может быть удобным средством для инициализации.


### 10. Что представляют собой методы с переменным числом параметров, как передаются параметры в такие методы и что представляет собой такой параметр в методе? Как осуществляется выбор подходящего метода, при использовании перегрузки для методов с переменным числом параметров?

В языке Java существуют методы, которые могут принимать переменное количество аргументов. Они называются методами с аргументами переменной длины (var-args).
Для указания аргументов переменной длины служат три точки.

**Например:**
```
static void test(int... array)
```
Наряду с параметром переменной длины у метода могут быть и "обычные" параметры. Но параметр переменной длины должен быть последним среди всех параметров, объявляемых в методе.

**Например:**
```
static void test(double d, int... array)
```
Метод может содержать только один параметр с переменным количеством аргументов.
Применение аргументов переменной длины

В следующем примере показан метод test(), объявленный с переменным количеством аргументов типа int. Внутри метода мы обращаемся к этим переменным как к массиву. При вызове этого метода можно передать любое, даже нулевое количество аргументов, а также массив:
```
public class VarArgs {
    static void test(int... array) {
        System.out.println("Количество аргументов: " + array.length);
        for (int a : array) {
            System.out.print(a + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        test();
        test(1);
        test(1, 2);
        test(new int[]{1, 3});
    }
}
```
Методы с переменным числом аргументов можно перегружать.

**Рассмотрим пример:**

**Перегрузка методов с аргументами переменной длины**

При вызове метода без аргументов, подходят два метода - test(double... array) и test(int... array). В этом случае будет вызван метод с меньшим диапазоном значений - test(int... array).
При вызове метода test() с одним значением типа int -  test(3), будет выбран метод test(int a).
```
public class VarArgs2 {
    static void test(double... array) {
        System.out.println("test(double... array)");
        System.out.println("Количество аргументов: " + array.length);
        for (double a : array) {
            System.out.print(a + " ");
        }
        System.out.println();
    }

    static void test(int... array) {
        System.out.println("test(int... array)");
        System.out.println("Количество аргументов: " + array.length);
        for (int a : array) {
            System.out.print(a + " ");
        }
        System.out.println();
    }

    static void test(int a) {
        System.out.println("test(int a)");
    }

    public static void main(String[] args) {
        test();
        test(3);
        test(1.0);
        test(1, 2);
    }
}
```
Результат выполнения:
```
test(int... array)
Количество аргументов: 0

test(int a)
test(double... array)
Количество аргументов: 1
1.0
test(int... array)
```
Количество аргументов: 2
1 2
При перегрузке метода, принимающего аргументы переменной длины, могут происходить непредвиденные ошибки. Они связаны с неоднозначностью, которая может возникать при вызове перегружаемого метода с аргументами переменной длины.
В следующем примере метод test перегружен - один вариант принимает значения var-ags типа boolean, а второй тоже var-ags, но типа int. При вызове метода test() без аргументов, возникает ошибка неоднозначности - JVM не может выбрать необходимый метод.


### 11. Чем является класс Object? Перечислите известные вам методы класса Object, укажите их назначение.

В Java есть специальный суперкласс Object и все классы являются его подклассами. Поэтому ссылочная переменная класса Object может ссылаться на объект любого другого класса. Так как массивы являются тоже классами, то переменная класса Object может ссылаться и на любой массив.

Все классы являются наследниками суперкласса Object. Это не нужно указывать явно. В результате объект Object может ссылаться на объект любого другого класса.

**Методы класса  Object:**

•	public final native Class getClass() – возвращает в рантайме класс данного объекта.
•	public native int hashCode() – возвращает хеш-код
•	public boolean equals(Object obj) – сравнивает объекты.
•	protected native Object clone() throws CloneNotSupportedException – клонирование объекта
•	public String toString() – возвращает строковое представление объекта.
•	public final native void notify() – просыпается один поток, который ждет на “мониторе” данного объекта.
•	public final native void notifyAll() – просыпаются все потоки, которые ждут на “мониторе” данного объекта.
•	public final native void wait(long timeout) throws InterruptedException – поток переходит в режим ожидания в течение указанного времени.
•	public final void wait() throws InterruptedException – приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() методы для этого объекта.
•	public final void wait(long timeout, int nanos) throws InterruptedException – приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() для этого метода, или пока не истечет указанный промежуток времени.
•	protected void finalize() throws Throwable – вызывается сборщиком мусора, когда garbage collector определил, что ссылок на объект больше нет.

### 12. Что такое хэш-значение? Объясните, почему два разных объекта могут сгенерировать одинаковые хэш-коды?

Функция hash - это способ создания компактного представления произвольно большого объема данных. В java с помощью метода hashcode это означает, что каким-то образом описывается состояние вашего объекта (независимо от его размера) в int (4 байта). И обычно пишется довольно быстро, как описано ниже.

Функция HASH: - функция hash берет группу символов (называемую ключом) и сопоставляет ее со значением определенной длины (называемым значением hash или hash). Значение hash является репрезентативным для исходной строки символов, но обычно меньше, чем оригинал. Хэширование выполняется для индексирования и поиска элементов в базах данных, поскольку более короткое значение hash легче найти, чем более длинную строку. Хэширование также используется в шифровании. Этот термин также известен как алгоритм хэширования или функция дайджеста сообщений.

•	У одинаковых объектов всегда одинаковые хеши
•	У одного и того же объекта всегда должен быть неизменяемый хешкод(если значения внутри объекта не изменились)
•	У разных объектов иногда могут быть одинаковые хеши
Если два объекта равны в соответствии с equal(), то вызов метода hashcode для каждого из этих двух объектов должен выдавать один и тот же хэш-код
 ```
public class Test {
    public static void main(String[] args) {

        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        map.put(1, 11);
        map.put(4, 11);
        System.out.println(map.hashCode());
        Map<Integer, Integer> map1 = new HashMap<Integer, Integer>();
        map1.put(1, 11);
        map1.put(4, 11);
        System.out.println(map1.hashCode());
        if (map.equals(map1)) {
            System.out.println("equal ");
        }
    }
}
```

### 13. Как вы думаете, для чего используется наследование классов в java-программе? Приведите пример наследования. Как вы думаете, поля и методы, помеченными модификатором доступа private, наследуются?

**Наследование**

Давайте посмотрим еще раз на диаграмму телефонов. Можно заметить, что она представляет собой иерархию, в которой модель,
расположенная ниже обладает всеми признаками моделей, расположенных выше по ветке, плюс своими собственными. Например,
смартфон, использует сотовую сеть для связи (обладает свойствами сотового телефона), является беспроводным и
переносным (обладает свойствами беспроводного телефона) и может принимать и делать вызовы (свойствами телефона). В этом
случае мы можем говорить о наследовании свойств объекта.

В программировании наследование заключается в использовании уже существующих классов для описания новых.

Рассмотрим пример создания класса смартфон с помощью наследования. Все беспроводные телефоны работают от аккумуляторных
батарей, которые имеют определенный ресурс работы в часах.

**Поэтому добавим это свойство в класс беспроводных телефонов:**

    public abstract class WirelessPhone extends AbstractPhone {
        private int hour;
        public WirelessPhone(int year, int hour) {
            super(year);
            this.hour = hour;
        }
    }

**Сотовые телефоны наследуют свойства беспроводного телефона, мы также добавили в этот класс реализацию методов call и ring:**

    public class CellPhone extends WirelessPhone {
    public CellPhone(int year, int hour) {
    super(year, hour);
    }
    
        @Override
        public void call(int outputNumber) {
            System.out.println("Вызываю номер " + outputNumber);
        }
    
        @Override
        public void ring(int inputNumber) {
            System.out.println("Вам звонит абонент " + inputNumber);
        }
    }

И, наконец, класс смартфон, который в отличие от классических сотовых телефонов имеет полноценную операционную систему. В смартфон можно добавлять новые программы, поддерживаемые данной операционной системой, расширяя, таким образом, его функциональность.

**С помощью кода класс можно описать так:**

    public class Smartphone extends CellPhone {
    
        private String operationSystem;
    
        public Smartphone(int year, int hour, String operationSystem) {
            super(year, hour);
            this.operationSystem = operationSystem;
        }
    public void install(String program){
    System.out.println("Устанавливаю " + program + "для" + operationSystem);
    }
    
    }

Как видите, для описания класса Smartphone мы создали совсем немного нового кода, но получили новый класс с новой функциональностью. Использование принципа наследование ООП позволяет значительно уменьшить объем кода, а значит, и облегчить работу программисту.


### 14. Укажите, как вызываются конструкторы при создании объекта производного класса? Что в конструкторе класса делает оператор super()? Возможно ли в одном конструкторе использовать операторы super() и this()?

Дело в том, что в Java несколько разных классов могут иметь общее происхождение.

![Alt-рисунок 3](https://cdn.javarush.ru/images/article/25f9b7a8-2cbe-446d-b325-58a02ded49ad/800.webp)

Это называется наследованием. У нескольких классов-потомков может быть один общий класс-предок.

**Например, представим что у нас есть класс Animal (животное):**

    public class Animal {
    
    String name;
    int age;
    }
Мы можем создать для него, например, 2 класса-потомка — Cat и Dog. Это делается с использованием ключевого слова extends.

    public class Cat extends Animal {
    
    }
    
    public class Dog extends Animal {
    
    }

Это может нам пригодиться в будущем. Например, если будет задача ловить мышей — создадим в программе объект Cat. Если задача бегать за палочкой — тут мы используем объект Dog. А если будем создавать программу, симулирующую ветеринарную клинику — она будет работать с классом Animal (чтобы уметь лечить и кошек, и собак).

Очень важно запомнить на будущее, что при создании объекта в первую очередь вызывается конструктор его базового класса, а только потом — конструктор самого класса, объект которого мы создаем.

То есть при создании объекта Cat сначала отработает конструктор класса Animal, а только потом конструктор Cat.

Чтобы убедиться в этом — добавим в конструкторы Cat и Animal вывод в консоль.

    public class Animal {
    
    public Animal() {
    System.out.println("Отработал конструктор Animal");
    }
    }
    
    
    public class Cat extends Animal {
    
    public Cat() {
    System.out.println("Отработал конструктор Cat!");
    }
    
    public static void main(String[] args) {
    Cat cat = new Cat();
    }
    }

Для чего это нужно? Например, чтобы не дублировать общие поля двух классов. Например, у каждого животного есть сердце и мозг, но не у каждого есть хвост.

Мы можем объявить общие для всех животных поля brain и heart в родительском классе Animal, а поле tail — в подклассе Cat.

Теперь мы создадим конструктор для класса Cat, куда передадим все 3 поля.

    public class Cat extends Animal {
    
    String tail;
    
    public Cat(String brain, String heart, String tail) {
    this.brain = brain;
    this.heart = heart;
    this.tail = tail;
    }
    
    public static void main(String[] args) {
    Cat cat = new Cat("Мозг", "Сердце", "Хвост");
    }
    }

Эти поля “подтянулись” из базового класса Animal. У класса-наследника есть доступ к полям базового класса, поэтому в нашем классе Cat они видны. Поэтому нам не нужно в классе Cat дублировать эти поля — мы можем взять их из класса Animal.

Более того, мы можем явно вызвать конструктор базового класса в конструкторе класса-потомка. Базовый класс еще называют “суперклассом”, поэтому в Java для его обозначения используется ключевое слово super.

В предыдущем примере

    public Cat(String brain, String heart, String tail) {
    this.brain = brain;
    this.heart = heart;
    this.tail = tail;
    }

Мы отдельно присваивали каждое поле, которое есть в нашем родительском классе. На самом деле этого можно не делать.

**Достаточно вызвать конструктор родительского класса и передать ему нужные параметры:**

    public class Animal {
    
    String brain;
    String heart;
    
    public Animal(String brain, String heart) {
    this.brain = brain;
    this.heart = heart;
    }
    
    public class Cat extends Animal {
    
    String tail;
    
    public Cat(String brain, String heart, String tail) {
    super(brain, heart);
    this.tail = tail;
    }
    
    public static void main(String[] args) {
    Cat cat = new Cat("Мозг", "Сердце", "Хвост");
    }
    }

В конструкторе Cat мы вызвали конструктор Animal и передали в него два поля. Нам осталось явно проинициализировать только одно поле — tail, которого в Animal нет.

Помнишь, мы говорили о том, что при создании объекта в первую очередь вызывается конструктор класса-родителя? Так вот, именно поэтому слово super() всегда должно стоять в конструкторе первым!

Иначе логика работы конструкторов будет нарушена и программа выдаст ошибку.

    public class Cat extends Animal {
    
    String tail;
    
    public Cat(String brain, String heart, String tail) {
    this.tail = tail;
    super(brain, heart);//ошибка!
    }
    
    public static void main(String[] args) {
    Cat cat = new Cat("Мозг", "Сердце", "Хвост");
    }
    }

Компилятор знает, что при создании объекта класса-потомка сначала вызывается конструктор базового класса. И если ты попытаешься вручную изменить это поведение - он не позволит этого сделать.

**Процесс создания объекта.**

Выше мы с тобой рассмотрели пример с базовым и родительским классом — Animal и Cat.

Теперь на примере этих двух классов мы рассмотрим процесс создания объекта и инициализации переменных.

Мы знаем, что переменные бывают статическими и переменными экземпляра (нестатическими). Также мы знаем, что в базовом классе Animal есть свои переменные, а в классе-потомке Cat — свои.

Добавим к классу Animal и Cat по одной статической переменной для наглядности.

Переменная animalCount в классе Animal будет означать общее число видов животных на земле, а переменная catsCount — число видов семейства кошачьих.

Кроме того, присвоим всем нестатическим переменным у обоих классов стартовые значения (которое потом изменится в конструкторе).

    public class Animal {
    
    String brain = "Изначальное значение brain в классе Animal";
    String heart = "Изначальное значение heart в классе Animal";
    
    public static int animalCount = 7700000;
    
    public Animal(String brain, String heart) {
    System.out.println("Выполняется конструктор базового класса Animal");
    System.out.println("Были ли уже проинициализированы переменные класса Animal?");
    System.out.println("Текущее значение статической переменной animalCount = " + animalCount);
    System.out.println("Текущее значение brain в классе Animal = " + this.brain);
    System.out.println("Текущее значение heart в классе Animal = " + this.heart);
    System.out.println("Были ли уже проинициализированы переменные класса Cat?");
    System.out.println("Текущее значение статической переменной catsCount = " + Cat.catsCount);
    
           this.brain = brain;
           this.heart = heart;
           System.out.println("Конструктор базового класса Animal завершил работу!");
           System.out.println("Текущее значение brain = " + this.brain);
           System.out.println("Текущее значение heart = " + this.heart);
    }
    }
    
    public class Cat extends Animal {
    
    String tail = "Изначальное значение tail в классе Cat";
    
    static int catsCount = 37;
    
    public Cat(String brain, String heart, String tail) {
    super(brain, heart);
    System.out.println("Конструктор класса Cat начал работу (конструктор Animal уже был выполнен)");
    System.out.println("Текущее значение статической переменной catsCount = " + catsCount);
    System.out.println("Текущее значение tail = " + this.tail);
    this.tail = tail;
    System.out.println("Текущее значение tail = " + this.tail);
    }
    
    public static void main(String[] args) {
    Cat cat = new Cat("Мозг", "Сердце", "Хвост");
    }
    }

Итак, мы создаем новый объект класса Cat, унаследованного от Animal. Добавим в нашу программу подробный консольный вывод, чтобы посмотреть что и в каком порядке будет происходить.

**Вот что будет выведено в консоль в результате создания объекта Cat:**

    Выполняется конструктор базового класса Animal
    Были ли уже проинициализированы переменные класса Animal?
    Текущее значение статической переменной animalCount = 7700000
    Текущее значение brain в классе Animal = Изначальное значение brain в классе Animal
    Текущее значение heart в классе Animal = Изначальное значение heart в классе Animal
    Были ли уже проинициализированы переменные класса Cat?
    Текущее значение статической переменной catsCount = 37
    Конструктор базового класса Animal завершил работу!
    Текущее значение brain = Мозг
    Текущее значение heart = Сердце
    Конструктор класса Cat начал работу (конструктор Animal уже был выполнен)
    Текущее значение статической переменной catsCount = 37
    Текущее значение tail = Изначальное значение tail в классе Cat
    Текущее значение tail = Хвост

Итак, теперь мы наглядно видим в каком порядке происходит инициализация переменных и вызов конструкторов при создании нового объекта:
1. Инициализируются статические переменные базового класса (Animal). В нашем случае — переменной animalCount класса Animal присваивается значение 7700000.

2. Инициализируются статические переменные класса-потомка (Cat). Обрати внимание — мы все еще внутри конструктора Animal, а в консоли уже написано:

    Выполняется конструктор базового класса Animal
    Были ли уже проинициализированы переменные класса Animal?
    Текущее значение статической переменной animalCount = 7700000
    Текущее значение brain в классе Animal = Изначальное значение brain в классе Animal
    Текущее значение heart в классе Animal = Изначальное значение heart в классе Animal
    Были ли уже проинициализированы переменные класса Cat?
    Текущее значение статической переменной catsCount = 37

3. Дальше инициализируются нестатические переменные базового класса. Мы специально присвоили им первоначальные значения, которые потом в конструкторе меняются на новые. Конструктор Animal еще не отработал до конца, но первоначальные значения brain и heart уже присвоены:

   Выполняется конструктор базового класса Animal
   Были ли уже проинициализированы переменные класса Animal?
   Текущее значение статической переменной animalCount = 7700000
   Текущее значение brain в классе Animal = Изначальное значение brain в классе Animal
   Текущее значение heart в классе Animal = Изначальное значение heart в классе Animal

4. Начинает работу конструктор базового класса.

В том, что этот этап идет только четвертым по счету, мы уже убедились: в первых трех пунктах на момент начала работы конструктора Animal многим переменным уже присвоены значения.

5. Инициализация нестатических полей дочернего класса (Cat).

Она происходит раньше, чем конструктор Cat начинает работу.

На момент, когда он начал работу, у переменной tail уже было значение:

    Конструктор класса Cat начал работу (конструктор Animal уже был выполнен)
    Текущее значение статической переменной catsCount = 37
    Текущее значение tail = Изначальное значение tail в классе Cat

6. Вызывается конструктор класса потомка Cat

this и super - это два специальных ключевых слова в Java, которые представляют соответственно текущий экземпляр класса и его суперкласса. Java-программисты часто путают эти слова и обнаруживают слабую осведомленность об их специальных свойствах, о которых нередко спрашивают на интервью по Java Сore. Вот, например, пара вопросов, из того, что сразу приходит на ум, о this и super, Можно ли присвоить другое значение ключевому слову this в Java? и какая разница между ключевыми словами this и super в Java. Не знаете? Ну что ж, здесь я ответа не даю — его можно найти в конце статьи.

Так вот, как я уже сказал в начале, главное отличие между this и super в Java в том, что this представляет текущий экземпляр класса, в то время как super - текущий экземпляр родительского класса. Вот один из примеров использования переменных this и super — вы наверняка уже видели примеры вызовов конструкторов одного из другого, т.н. вызовы конструкторов по цепочке, это возможно благодаря использованию ключевых слов this и super. Внутри класса для вызова своего конструктора без аргументов используется this(), тогда как super()используется для вызова конструктора без аргументов, или как его ещё называют, конструктора по умолчанию родительского класса. Между прочим, таким способом вызывать можно не только конструктор без аргументов, а и вообще любой другой конструктор, передав ему соответствующие параметры. Скоро мы увидим пример такого использования this и super.

Ещё this и super в Java используются для обращения к переменным экземпляра класса и его родителя. Вообще-то, к ним можно обращаться и без префиксов super и this, но только если в текущем блоке такие переменные не перекрываются другими переменными, т.е. если в нем нет локальных переменных с такими же именами, в противном же случае использовать имена с префиксами придется обязательно, но это не беда, т.к. в таком виде они даже более читабельны. Классическим примером такого подхода является использование this внутри конструктора, который принимает параметр с таким же именем, как и у переменной экземпляра. Дальше в статье мы узнаем, какие ещё есть отличия между super и this, и рассмотрим некоторые примеры их использования.

**Чем this и super похожи**

Прежде чем рассматривать отличия ключевых слов this и super, давайте посмотрим на некоторые их сходства:
1. И this, и super — это нестатические переменные, соответственно их нельзя использовать в статическом контексте, а это означает, что их нельзя использовать в методе main. Это приведет к ошибке во время компиляции "на нестатическую переменную this нельзя ссылаться из статического контекста". То же самое произойдет, если в методе main воспользоваться ключевым словом super.

2. И this, и super могут использоваться внутри конструкторов для вызова других конструкторов по цепочке, нпр., this() и super() вызывают конструктор без аргументов наследующего и родительского классов соответственно.

В примере ниже мы сначала передаем вызов из конструктора без аргументов класса B в конструктор этого же класса B, принимающий один параметр типа String, из которого, в свою очередь, с помощью super("") вызывается конструктор с одним аргументом из суперкласса.

    class A{
    
        A(){
            System.out.println("Конструктор без аргументов класса A");
        }
    
        A(String args){
            System.out.println("Конструктор с одним аргументом класса A");
        }
    }
    
    class B extends A{
    
    B(){
    this(""); // вызов конструктора с одним аргументом класса B
    System.out.println("Конструктор без аргументов класса B");
    }
    
    B(String args){
    super(""); // вызов конструктора с одним аргументом класса A
    System.out.println("Конструктор с одним аргументом класса B");
    }
    }
    
    // Тест-класс и вывод
    public class Test {
    
        public static void main(String args[]) {
           B b = new B();
        }
    
    }

**Вывод:**
    
    Конструктор с одним аргументом класса A
    Конструктор с одним аргументом класса B
    Конструктор без аргументов класса B

Внутри конструктора this и super должны стоять выше всех других выражений, в самом начале, иначе компилятор выдаст сообщение об ошибке. Из чего следует, что в одном конструкторе не может быть одновременно и this(), и super().

**Различия в super и this**

Теперь мы знаем как использовать ключевые слова super и this и понимаем для чего они нужны. Но есть ещё один вариант использования этих ключевых слов, о котором я не сказал - во Внутренних классах, где с их помощью очень удобно ссылаться на внешний класс, используя форму записи Outer.this для его текущего экземпляра и Outer.super — для его родителя. Не забудьте вместо Outer подставить имя внешнего класса. А теперь давайте кратко перечислим главные отличия между ключевыми словами this и super
переменная this ссылается на текущий экземпляр класса, в котором она используется, тогда как super — на текущий экземпляр родительского класса.

Каждый конструктор при отсутствии явных вызовов других конструкторов неявно вызывает с помощью super() конструктор без аргументов родительского класса, при этом у вас всегда остается возможность явно вызвать любой другой конструктор с помощью либо this(), либо super().
Пожалуй, это все, что можно сказать о различиях между ключевыми словами this и super в Java и о том, как они используются в программах. Как мы увидели, основное их назначение - вызывать один конструктор из другого и ссылаться на переменные экземпляра, объявленные в текущем классе и его родительском классе. Не забывайте, что это не совсем обычные переменные, а сейчас - ответ на мой вопрос, который я задавал в первом параграфе. Нет, переменной this нельзя присвоить новое значение, потому что она объявлена как final. Можете попробовать сделать это в IDE - получите ошибку компиляции "нельзя присвоить новое значение переменной this — она объявлена как final".

### 15. Объясните, как вы понимаете утверждения: “ссылка базового класса может ссылаться на объекты своих производных типов” и “объект производного класса может быть использован везде, где ожидается объект его базового типа”. Верно ли обратное и почему?


### 16. Что такое переопределение методов? Как вы думаете, зачем они нужны? Можно ли менять возвращаемый тип при переопределении методов? Можно ли менять атрибуты доступа при переопределении методов? Можно ли переопределить методы в рамках одного класса?

Полиморфизм позволяет вам определить один интерфейс и иметь для него несколько реализаций. 
Это один из основных принципов объектно-ориентированного программирования. 

Слово «полиморфизм» буквально означает «состояние наличия многих форм» или «способность принимать разные формы». 
При применении к объектно-ориентированным языкам программирования, таким как Java, он описывает способность 
языка обрабатывать объекты разных типов и классов через единый, однородный интерфейс.Полиморфизм позволяет 
вам определить один интерфейс и иметь для него несколько реализаций. Это один из основных принципов 
объектно-ориентированного программирования. Слово «полиморфизм» буквально означает «состояние наличия многих 
форм» или «способность принимать разные формы». При применении к объектно-ориентированным языкам 
программирования, таким как Java, он описывает способность языка обрабатывать объекты разных типов и 
классов через единый, однородный интерфейс.

Переопределенный метод вызывается в соответствии с объектом, которому принадлежит метод, а не по типу ссылки.

Private, final и static методы используют статические привязки и связаны компилятором, 
в то время как виртуальные методы связываются во время выполнения на основе обрабатываемого объекта.

Используйте аннотацию Override, чтобы компилятор мог проверить, что вы действительно переопределяете метод, когда вы на это рассчитываете. Таким образом, если вы совершаете распространенную ошибку, например, опечатку в имени метода или неправильно задаете параметры, вы будете предупреждены о том, что ваш метод фактически не переопределяет в то время, как вы уверены в обратном. Во-вторых, это улучшает читаемость кода, делая переопределение более очевидным.

Кроме того, начиная с Java 1.6 вы можете воспользоваться Override с теми же целями, чтобы отметить, когда метод реализует интерфейс.


Если мы используем переопределение, то метод переопределения должен иметь ту же сигнатуру, что и переопределенный метод. Вы можете соответствующим образом изменить сигнатуру метода в своем дочернем классе, то есть количество аргументов, тип и порядок аргументов и тип возвращаемого значения. Но это называется перегрузкой.

    package com.me.overriding;
    class Parent_params {
    void method(String a, String b, int v, float d) {
    System.out.println("parent");
    }
    void method2(String a, String b, int v) {
    System.out.println("parent");
    }
    void method3(String a, int v) {
    System.out.println("parent");
    }
    }
    class Child_Params extends Parent_params {
    //Если мы хотим переопределить дочерний класс,
    //вам нужно иметь такое же количество параметров, что и родительский
    //НЕПРАВИЛЬНО...
    /*@Override
    void method(String a){
    System.out.println("child");
    }*/
    //Порядок параметров должен также совпадать с родительским
    //НЕПРАВИЛЬНО
    /*@Override
    void method(String a,float d,int a,String b){
    System.out.println("parent");
    }*/
    //Override
    @Override
    void method(String a, String b, int v, float d) {
    System.out.println("child");
    }
    //Перегрузка
    //Мы можем определить метод таким образом
    void method(String a, String b, int v) {
    System.out.println("child");
    }
    void method2(String a, int b, String v) {
    System.out.println("child");
    }
    void method3(int v, String a) {
    System.out.println("child");
    }
    }
    public class Override_Params {
    public static void main(String[] args) {
    String temp = "Monday";
    Child_Params child_Params = new Child_Params();
    /*Parent_params params=new Child_Params();
    child_Params=(Child_Params) params;
    child_Params.method(temp,temp,2);*/
    Parent_params params2 = new Parent_params();
    child_Params = (Child_Params) params2;
    child_Params.method(temp, temp, 2);
    /*up vote
    3
    down vote
    accepted
    Создав объект, вы не можете изменить его тип.
    Вот почему вы не можете привести тип Animal к типу Dog.
    Однако, если вы создаете объект подкласса,
    вы можете сохранить ссылку на него в переменной типа суперкласса,
    и позже вы можете применить его к типу подкласса.
    Это будет работать :
    Animal a = new Dog ();
    Dog d = (Dog) a;*/
    }
    }

***Тип возврата метода***

Типы возвращаемых данных могут варьироваться в зависимости от методов, которые переопределяют друг друга, 
если типы возврата являются ссылочными типами. Java поддерживает ковариантные возвращения — специализацию 
типа возврата к подтипу. Объявление метода d1 с типом возврата R1 заменит возвращаемое значение метода d2 
с возвращаемым типом R2 тогда и только тогда, когда выполняются следующие условия:
* Если R1 void, то R2 является void.
* Если R1 является примитивным типом, то R2 идентичен R1.
* Если R1 является ссылочным типом, то: R1 является либо подтипом R2, либо R1 может быть преобразован в подтип R2 путем unchecked преобразования или
* R1 = | R2 |

  

### 17. Определите правило вызова переопределенных методов. Можно ли статические методы переопределить нестатическими и наоборот?

Переопределение метода (англ. Method overriding) в объектно-ориентированном программировании — одна из возможностей языка программирования, позволяющая подклассу или дочернему классу обеспечивать специфическую реализацию метода, уже реализованного в одном из суперклассов или родительских классов.

Оно, в общем-то, правильное. Переопределение позволяет взять какой-то метод родительского класса и написать в каждом классе-наследнике свою реализацию этого метода. Новая реализация «заменит» родительскую в дочернем классе.

1. Создали в каждом классе-наследнике метод с названием родительского класса.
2. Сообщили компилятору, что мы не просто так назвали метод так же, как в классе-родителе: хотим переопределить его поведение. Для этого «сообщения» компилятору мы поставили над методом аннотацию @Override («переопределен»).
Проставленная над методом аннотация @Override сообщает компилятору (да и читающим твой код программистам тоже): «Все ок, это не ошибка и не моя забывчивость. Я помню, что такой метод уже есть, и хочу переопределить его».

3. Написали нужную нам реализацию для каждого класса-потомка. Змея при вызове voice() должна шипеть, медведь — рычать и т.д.

***Правило:***

1. У переопределенного метода должны быть те же аргументы, что и у метода родителя.
2. У переопределенного метода должны быть тот же тип возвращаемого значения, что и у метода родителя.
3. Модификатор доступа у переопределенного метода также не может отличаться от «оригинального»:
4. Переопределение методов в Java — один из инструментов для реализации идеи полиморфизма (принципа ООП, о котором мы рассказывали в прошлой лекции).

Поэтому главным преимуществом его использования будет та же гибкость, о которой мы говорили ранее. Мы можем выстроить простую и логичную систему классов, каждый из которых будет обладать специфическим поведением (собаки лают, кошки мяукают), но единым интерфейсом — один метод voice() на всех вместо кучи методов voiceDog(), voiceCat() и т.д.

static методы - это методы уровня class . Концепция скрытия используется для методов static . Нет, статические методы не могут быть переопределены, поскольку они являются частью класса, а не объекта.


### 18. Какие свойства имеют финальные методы и финальные классы? Как вы думаете, зачем их использовать?

Обозначая метод класса модификатором final, мы имеем ввиду, что ни один производный класс не в состоянии переопределить этот метод, изменив его внутреннюю реализацию. Другими словами, речь идет о финальной версии метода. Класс в целом также может быть помечен как final.

Класс, помеченный как final, не поддается наследованию и все его методы косвенным образом приобретают свойство final.

Применение признак а final в объявлениях классов и методов способно повысить уровень безопасности кода. Если класс снабжен модификатором final, никто не в Состоянии расширить класс и, вероятно, нарушить при этом его контракт. Если признаком final обозначен метод, вы можете полностью доверять его внутренней реализации во всех ситуациях, не опасаясь "подделки". Уместно применить final, например, в объявлении метода, предусматривающего проверку пароля, вводимого пользователем, чтобы гарантировать точное Исполнение того, что методом предусмотрено изначально. Возможному злоумышленнику не удастся изменить исходную реализацию такого метода, "подсунув" программе его переопределенную версию, которая, скажем, всегда возвращает значение true, свидетельствующее об успешной регистрации пользователя, независимо от того, какой пароль он ввел на самом деле. Вы вправе, если позволяет конкретная ситуация, пойти дальше и объявить как final класс целиком; метод ValidatePassword приобретёт то же свойство косвенным путём.

Употребление модификатора final в объявлении метода или класса накладывает серьезные ограничения на возможность дальнейшего использования и развития кода. Применение final в объявлении метода – это верный показатель того, что реализация метода самодостаточна и полностью завершена. Другие программисты, которые захотят воспользоваться вашим классом, расширив его функции в угоду собственным потребностям, будут стеснены в выборе средств достижения цели либо полностью лишены таковых. Пометив признаком final класс в целом, вы запретите возможность его наследования и, вероятно, существенно снизите его практическую ценность для других. Собравшись применить модификатор final, убедитесь, готовы ли ВЫ к подобным жертвам и стоит ли их принести.

Во многих случаях для достижения достаточного уровня безопасности кода вовсе нет необходимости обозначать весь класс как final – вполне возможно сохранить способность класса к расширению, пометив модификатором final только его "критические" структурные элементы. В этом случае вы оставите в неприкосновенности основные функции класса и одновременно разрешите его наследование с добавлением новых членов, но без переопределения "старых". Разумеется, поля, к которым обращается код методов final, должны быть в свою очередь обозначены как final либо private, поскольку в противном случае любой производный класс получит возможность изменять их содержимое, воздействуя на поведение соответствующих методов.

Еще один эффект применения модификатора final связан с упрощением задачи оптимизации кода, решаемой компилятором. Вот что происходит, когда вызывается метод, не помеченный как final, исполняющая система определяет фактический класс объекта, связывает вызов с наиболее подходящим кодом из группы перегруженных методов и передает управление этому коду. Но если бы, например, метод getName в примере класса Attr, рассмотренном раньше, был обозначен как final, операция обращения к нему, возможно, была бы заметно упрощена. В самом тривиальном случае, подобном тому, который касается getName, компилятор может попросту заменить вызов метода кодом его тела. Такой механизм носит название встраивания кода (inlining). При использовании inline-версии метода getName два следующих выражения выполняются совершенно одинаково:

    system.out.println("id = " + rose.name);
    system.out.println("id = " + rose.getName());

Хотя приведенные выражения равнозначны, второе все-таки обладает преимуществом, поскольку метод getName позволяет придать полю name свойство "только для чтения", а коду класса – некую степень абстракции, которая обеспечивает возможность более свободного изменения реализации класса.

Та же схема оптимизации может быть применена компилятором и по отношению к методам private и statiс, так как и они не допускают переопределения.

Использование модификатора final в объявлениях классов способствует также повышению эффективности некоторых операций проверки типов. В этом случае многие подобные операции могут быть выполнены уже на стадии компиляции и поэтому потенциальные ошибки выявляются гораздо раньше. Если компилятор встречает в исходном тексте ссылку на класс final, он может быть "уверен", что соответствующий объект относится именно к тому типу, который указан. Компилятор в состоянии сразу определить место, занимаемое классом в общей иерархии классов, и проверить, верно тот используется или нет. Если модификатор final не применяется, соответствующие проверки осуществляются только на стадии выполнения программы.


### 19. Укажите правила приведения типов при наследовании. Напишите примеры явного и неявного преобразования ссылочных типов. Объясните, какие ошибки могут возникать при явном преобразовании ссылочных типов.

представь себе цепочку наследования класса: класс, его родитель, родитель родителя и т.д. до самого класса Object. Т.к. класс содержит все методы класса, от которого он был унаследован, то объект этого класса можно сохранить в переменную любого из его типов родителей.

***Приведение типов (преобразование типов)*** — преобразование значения переменной одного типа в значение другого типа.

Давайте посмотрим на примере, что это такое и с чем его едят.

У нас есть некоторая иерархия классов. Тут видно все классы иерархии, кто кого наследует и методы каждого класса.

![Рисунок 4](https://cdn.javarush.ru/images/article/2d532843-98df-4604-b10c-ca422461c6c1/512.webp)

Есть расширяющее и сужающее приведение.

Мы видим, что класс Cat является наследником класса Pet. Pet, в свою очередь, наследник класса Animal.

Когда мы напишем:

    Animal animalCat = new Cat();
    Animal animalDog = new YorkshireTerrier();

Это расширяющее приведение (или неявное). Мы расширили ссылки animalCat и animalDog. Они ссылаются на объекты Cat и Dog. При таком приведении мы не можем через ссылку animalCat/animalDog вызвать методы, которые есть в Cat/Dog, но которых нету в Animal.

Сужающее приведение(или явное) происходит в обратную сторону:

    Animal animalCat = new Cat();
    Animal animalDog = new YorkshireTerrier();
    Cat cat =(Cat)animalCat;
    YorkshireTerrier dog = (YorkshireTerrier) animalDog;

Мы явно указали к какому типу хотим привести данный объект.

BUT, BE CAREFUL!!!
Если Вы сделаете вот так:

    Animal animalCat = new Cat();
    YorkshireTerrier dog = (YorkshireTerrier) animalCat;

компилятор пропустит этот код. А вот RunTime выкинет вам:

    Exception in thread "main" java.lang.ClassCastException: Animals.Cat cannot be cast to Animals.YorkshireTerrier



RunTime видит, что Cat и YorkshireTerrier два разных класса. Что бы избежать ClassCastException при сужающем преобразовании, используйте instanceof.


    Animal animalCat = new Cat();
    if (animalCat instanceof YorkshireTerrier)
    {
    YorkshireTerrier dog = (YorkshireTerrier) animalCat;
    }


Если animalCat является YorkshireTerrier, тогда произойдет присвоение, если нет — ничего не произойдет.


***А теперь зачем же это нужно, если мы теряем методы и можем получить такие ошибки***

Рассмотрим код который я сделал по диаграмме с Рис. 1. Класс Animal

    public abstract class Animal
    {
    String name;
    int age;
    String nameOfClass = getClass().getSimpleName();
    public void eat(){
    System.out.println(nameOfClass + ": Omnomnom");
    }
    public void sleep(){
    System.out.println(nameOfClass + ": Z-z-z-z");
    }
    }

Класс WildAnimal который наследуется от Animal

    public abstract class WildAnimal extends Animal
    {
    public void steelChicken()
    {
    System.out.println(nameOfClass+": Muhaha,I stole a chicken!");
    }
    }

Класс Pet который наследуется от Animal
    
    public abstract class Pet extends Animal
    {
    public void peeInTray(){
    System.out.println(nameOfClass + ": Master, I peed");
    }
    }
Класс Fox который наследуется от WildAnimal

    public class Fox extends WildAnimal
    {
    public void eatColobok(){
    System.out.println(nameOfClass + ": I will eat you, Colobok");
    }
    }

Класс Wolf который наследуется от WildAnimal

    public class Wolf extends WildAnimal
    {
    public void hawlAtTheMoon(){
    System.out.println(nameOfClass + ": Ouuuuu!!!Ouuuu!!!");
    }
    }

Класс Cat который наследуется от Pet

    public class Cat extends Pet
    {
    public void sleepOnKeyboard(){
    System.out.println(nameOfClass + ": Master, stop working!!I wanna sleep on your keyboard");
    }
    }

Класс YorkshireTerrier который наследуется от Pet

    public class YorkshireTerrier extends Pet
    {
    public void bark(){
    System.out.println(nameOfClass + ": Meow!!! Meow!!!");
    }
    }


Представьте себе ситуацию. Нам нужно собрать всех животных в один список, накормить их и потом уложить спать. Это легко сделать, если мы создадим ArrayList животных (Animal). И потом у каждого животного вызовем соответствующие методы:

    public class ZOO
    {
    public static void main(String[] args)
    {
    List<Animal> allAnimals = new ArrayList<>();
    allAnimals.add(new Cat());
    allAnimals.add(new Wolf());
    allAnimals.add(new Fox());
    allAnimals.add(new YorkshireTerrier());
    for (Animal animal : allAnimals)
    {
    animal.eat();
    animal.sleep();
    }
    }
    }

Я не могу у animal вызвать метод bark() или sleepOnKeyboard(). Потому что в листе allAnimals хранятся кот, волк, йорик и лиса, но они приведены к Animal. И у них есть только те методы, которые есть в Animal.



### 20. Что такое объект класса Class? Чем использование метода getClass() и последующего сравнения возвращенного значения с Type.class отличается от использования оператора instanceof?


Классы — это, можно сказать, основа основ программирования на Java. Когда ты станешь программистом, твоей основной задачей будет написание собственных классов с разным функционалом.
Класс — это, по сути, шаблон для объекта. Он определяет, как объект будет выглядеть и какими функциями обладать. Каждый объект является объектом какого-то класса.

****Рассмотрим самый простой пример:***

    public class Cat {
    
        String name;
        int age;
    
    }

Допустим, мы пишем программу, и в этой программе нам для чего-то нужны кошки (например, у нас ветеринарная клиника с возможностью онлайн-записи).

Мы создали класс Cat, и указали для него две переменные — строку name, и число age. Такие переменные классов называются полями.

По сути — это шаблон для всех кошек, которых мы создадим в будущем. У каждой кошки (объекта класса Cat) будет две переменные — имя и возраст.

    public class Cat {
    
        String name;
        int age;
    
        public static void main(String[] args) {
            Cat barsik = new Cat();
            barsik.age = 3;
            barsik.name = "Барсик";
    
            System.out.println("Мы создали кота по имени " + barsik.name + ", его возраст - " + barsik.age);
        }
    
    }

Вот так это работает! Мы создали кота, присвоили ему имя и возраст и вывели все это в консоль. Ничего сложного :)

Классы чаще всего описывают предметы и явления окружающего мира.

Кошка, стол, человек, молния, страница книги, колесо — все это в твоей программе будет создаваться с помощью отдельных классов.

Теперь давай обратим внимание на переменные, которые мы создали в классе Cat. Они называются полями, или переменными экземпляров. В названии, собственно, раскрыта вся их суть. Эти переменные будут у каждого экземпляра (объекта) класса Cat. У каждого кота, которого мы создадим, будет своя переменная name и своя переменная age. Логично, в общем-то: с настоящими котами все так и есть :)

Кроме переменных экземпляров существуют и другие — переменные классов, или статические. Дополним наш пример:

    public class Cat {
    
        String name;
        int age;
    
        static int count = 0;
    
        public static void main(String[] args) {
            Cat barsik = new Cat();
            barsik.age = 3;
            barsik.name = "Барсик";
            count++;
    
            Cat vasia = new Cat();
            vasia.age = 5;
            vasia.name = "Вася";
            count++;
    
            System.out.println("Мы создали кота по имени " + barsik.name + ", его возраст - " + barsik.age);
            System.out.println("Мы создали кота по имени " + vasia.name + ", его возраст - " + vasia.age);
    
            System.out.println("Общее количество котов = " + count);
        }
    }

Теперь у нас в классе появилась новая переменная — count (количество). Она отвечает за подсчет созданных котов. Каждый раз, когда в методе main мы создаем кота, мы увеличиваем эту переменную на 1.

Эта переменная обозначена ключевым словом static. Это значит, что она принадлежит классу, а не конкретному объекту класса. Что, конечно, логично: если имя у каждого кота должно быть свое, то счетчик котов нам нужен один на всех. Именно этого позволяет добиться слово static — переменная count одна для всех котов.

Обрати внимание: когда мы выводим ее в консоль, мы не пишем barsik.count или vasia.count. Она не принадлежит ни Барсику, ни Васе — она принадлежит всему классу Cat. Поэтому — просто count.

Можно также написать Cat.count — это тоже будет правильно.

С выводом в консоль переменной name у нас бы такое не прошло:


    public class Cat {
    
        String name;
        int age;
    
        static int count = 0;
    
        public static void main(String[] args) {
            Cat barsik = new Cat();
            barsik.age = 3;
            barsik.name = "Барсик";
            count++;
    
            System.out.println("Мы создали кота по имени " + name + ", его возраст - " + barsik.age);
    
            System.out.println("Общее количество котов = " + count);
        }
    }

Сравнение объектов в Java выполняется с помощью оператора сравнения == и метода equals(). Если оператор сравнения можно использовать с примитивами, то метод equals() используется только с экземплярами классов. При их использовании проверяется ссылаются ли переменные на один и тот же объект в памяти. Рассмотрим пример:



    Object ob1 = new Object();
    Object ob2 = ob1;
    
    System.out.println(ob1 == ob2); // true
    System.out.println(ob1.equals(ob2)); //true


Переменная ob1 содержит в себе ссылку на объект класса Object, а переменная ob2 просто ее копирует при объявлении, в итоге две переменных ссылаются на один и тот же объект в памяти, что при сравнении этих двух переменных всегда возвращается true. Другой пример:


    
    Object ob1 = new Object();
    Object ob2 = new Object();
    
    System.out.println(ob1 == ob2); // false
    System.out.println(ob1.equals(ob2)); //false

Теперь при объявлении каждой из переменных вызывается оператор new, который для каждой из них создает свой экземпляр класса Object, поэтому при сравнении этих двух переменных каждый раз возвращается false, потому что обе переменные указывают на разные объекты в разных участках памяти. Давайте теперь сравним что-то более конкретное, например, две строки:

    String str1 = new String("ABC");
    String str2 = new String("ABC");
    
    System.out.println(str1 == str2); // false
    System.out.println(str1.equals(str2)); //true

Как видите поведение метода equals() для класса String несколько отличается. Это происходит по одной простой причине, метод equals() определен в классе Object, поэтому все классы в Java его наследуют и вольны переопределять, что и было сделано в классе String. Как видите методом equals() проверяются на соответствие символы двух строк, если они совпадают, то метод возвращает true. Перед тем как приступить к переопределению метода equals() и комплексному сравнению объектов созданных нами классов, мы рассмотрим инструменты, которые нам для этого понадобятся: оператор instanceof и метод getClass().

***Оператор instanceof.***

Оператор instanceof служит для проверки к какому классу принадлежит объект. a instanceof B возвращает истину, если в переменной a содержится ссылка на экземпляр класса B, подкласс B (напрямую или косвенно, иначе говоря, состоит в иерархии наследования классов) или реализует интерфейс B (так же напрямую или косвенно). Давайте подробнее рассмотрим, как это работает на примере:

    class A{}
    class B extends A{}
    class C extends A{}


Иерархия классов очень проста, главный класс A, классы B и C от него наследуются. Посмотрим как поведет себя оператор instanceof с нашими классами:

    A aB = new B();
    System.out.println( aB instanceof B ); //true
    System.out.println( aB instanceof A ); //true
    System.out.println( aB instanceof C ); //false

Первая проверка возвращает true, потому что aB является экземпляром класса B. Вторая проверка возвращает true, потому что aB является подклассом A. И последний вызов оператора instanceof возвращает false, несмотря на то, что оба класса B и С наследуются от A, это совершенно разные классы. На самом деле, ситуация с последним вызовом оператора instanceof сложнее, чем может показаться. Типом переменной aB является класс A, иначе говоря, она может содержать в себе любой из трех классов, в том числе класс C и компилятор это проверяет, если возникнет ситуация, при которой оператор instanceof не сможет ни при каких условиях вернуть true – возникнет ошибка компиляции:

    B aB = new B();
    System.out.println( aB instanceof C ); //ошибка компиляции

Переменная с типом класса B на данном этапе нашей иерархии классов ни при каких условиях не может содержать в себе ссылку на класс С, поэтому возникает ошибка компиляции. Опять же, есть один нюанс, это правило не работает для интерфейсов:

    interface I{}
    class A{}
    A a = new A();
    System.out.println( a instanceof I ); //false


Как мы видим связи между классом A и интерфейсом I нет никакой, и тем не менее ошибки компиляции не возникает, а оператор instanceof возвращает false. Всегда существует вероятность в будущем реализации интерфейса тем или иным классом, поэтому в данном случае компилятор идет нам уступки. Если же класс реализует интерфейс, то оператор instanceof вернут true:

    interface I{}
    class A implements I{}
    A a = new A();
    System.out.println( a instanceof I ); //true

Как упоминалось ранее все классы наследуются от класса Object либо напрямую, либо через родительский класс, поэтому a instanceof Object всегда будет возвращать true за исключение одной ситуации:

    interface I{}
    class A implements I{}
    A a = new A();
    System.out.println( a instanceof I ); //true

Так вот, a instanceof Object всегда будет возвращать true, только если a не равна null.


***Метод getClass().***

Метод getClass() возвращает класс объекта, содержащий сведения об объекте: public final Class<?> getClass(). Как Вы можете заметить метод является конечным и переопределению не подлежит. С методом getClass() все обстоит несколько проще и очевидней нежели с оператором instanceof.

    package example;
    class A{}
    class B extends A{};
    public class Example{
    public static void main(String... args){
    A a = new A();
    A a1 = new A();
    B b = new B();
    A ab = new B();
    System.out.println(a.getClass() == a1.getClass()); // true
    System.out.println(a.getClass() == b.getClass()); // false
    System.out.println(a.getClass() == ab.getClass()); // false
    }
    }

Как видите, метод прост и эффективен, ровно до тех пор, пока не применен механизм наследования. При наследовании этот метод становится менее полезным. Это утверждение может многим показаться спорным, но мы к нему еще вернемся в конце главы, когда будем размышлять о том, каким должен быть идеальный метод для сравнения объектов.


### 21. Укажите правила переопределения методов equals(), hashCode() и toString().

Метод еquals() используется для сравнения объектов, а hashCode - для генерации целочисленного кода объекта.

Эти методы широко используются в стандартных библиотеках Java при вставке и извлечению объектов в HashMap. Метод equal также используется для обеспечения хранения только уникальных объектов в HashSet и других Set реализациях, а также в любых других случаях, когда нужно сравнивать объекты. Реализация по умолчанию метода equals() в классе java.lang.Object сравнивает ссылки на адреса в памяти, которые хранят переменные, и возвращает true только в том случае, если адреса совпадают, другими словами переменные ссылаются на один и тот же объект. Java рекомендует переопределять методы equals() и hashCode(), если предполагается, что сравнение должно осуществляться в соответсвии с естественной логикой или бизнес-логикой. Многие классы в стандартных библиотеках Java переопределяет их, например в классе String переопределяется equals таким образом, что возвращается true, если содержимое двух сравниваемых объектов одинаковое. В классе-обертке Integer метод equal переопределяется для выполнения численного сравнения, и так далее. Так как HashMap и HashTable в Java полагаются на методы equals() и hashCode() для сравнения своих key и values, то Java предлагает следующие правила для переопределения этих методов:

Рефлексивность: Объект должен равняться себе самому.

Симметричность: если a.equals(b) возвращает true, то b.equals(a) должен тоже вернуть true.

Транзитивность: если a.equals(b) возвращает true и b.equals(c) тоже возвращает true, то
c.equals(a) тоже должен возвращать true.

Согласованность: повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор, пока какое-либо значение свойств объекта не будет изменено. То есть, если два объекта равны в Java, то они будут равны пока их свойства остаются неизменными.
Сравнение null: объект должны быть проверен на null. Если объект равен null, то метод должен вернуть false, а не NullPointerException. Например, a.equals(null) должен вернуть false.
Соглашение между equals и hashCode в Java

Если объекты равны по результатам выполнения метода equals, тогда их hashcode должны быть одинаковыми.

Если объекты не равны по результатам выполнения метода equals, тогда их hashcode могут быть как одинаковыми, так и разными. Однако для повышения производительности, лучше, чтобы разные объекты возвращали разные коды.

Как переопределять метод equals в Java
```
@Override
public boolean equals(Object obj) {
/*1. Проверьте*/if (obj == this) {
/*и верните */ return true;
         }
```
Проверьте объект на null, а также проверьте, чтобы объекты были одного типа. Не делайте проверку с помощью instanceof так как такая проверка будет возвращать true для подклассов и будет работать правильно только в случае если ваш класс объявлен как immutable. Вместо этого можно использовать getClass();
```
if (obj == null || obj.getClass() != this.getClass()) {
            return false;
}
```
Объявите переменную типа, который вы сравниваете, и приведите obj к этому типу. Потом сравнивайте каждый атрибут типа начиная с численных атрибутов (если имеются) потому что численные атрибуты проверяются быстрей. Сравнивайте атрибуты с помощью операторов И и ИЛИ (так называемые short-circuit logical operators) для объединения проверок с другими атрибутами.
```
Person guest = (Person) obj;
        return id == guest.id && (firstName == guest.firstName ||
            (firstName != null && firstName.equals(guest.getFirstName())))
                && (lastName == guest.lastName || (lastName != null &&                      lastName .equals(guest.getLastName())));
}
```
Полный пример переопределения метода equals в Java
```
/** * Person class with equals and hashcode implementation in Java * @author Javin Paul */
public class Person {
    private int id;
    private String firstName;
    private String lastName;

    public int getId() { return id; }
    public void setId(int id) { this.id = id;}

    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }
    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
    @Override
    public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (obj == null || obj.getClass() != this.getClass()) {
        return false;
    }

    Person guest = (Person) obj;
    return id == guest.id
        && (firstName == guest.firstName
            || (firstName != null &&firstName.equals(guest.getFirstName())))        && (lastName == guest.lastName
            || (lastName != null && lastName .equals(guest.getLastName())
            ));
    }
    @Override
    public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((firstName == null) ? 0 : firstName.hashCode());             result = prime * result + id; result = prime * result +
        ((lastName == null) ? 0 : lastName.hashCode()); return result;
    }
 }
 ```
Распространенные ошибки при переопределении equals в Java

Вместо того, чтобы переопределять метод equals (Override) программист перегружает его (Overload)Синтаксис метода equals() в классе Object определен как public boolean equals(Object obj), но многие программисты ненароком перегружают метод: public boolean equals(Person obj) - вместо Object в качестве аргумента используют имя своего класса (напр. Person). Эту ошибку сложно обнаружить из-за static binding. Таким образом, если вы вызовите этот метод для объекта своего класса, то метод не просто скомпилируется, а даже сделает это корректно. Однако, если вы положите ваш объект в коллекцию, например ArrayList и вызовите метод contains(), работа которого основана на методе equals(), то метод contains не сможет обнаружить ваш объект.

При переопределении метода equals() не проверять на null переменные, что в конечном итоге заканчивается NullPointerException при вызове equals()

Третья распространенная ошибка это не переопределять метод hashCode(), а только equals(). Вы обязаны переопределять оба метода equals() и hashCode() в Java. Метод hashCode используется в hash -коллекциях(например HashSet), и чем меньше будет коллизий (одинаковый код при разных объектах) тем эффективнее эти коллекции будут работать с объектами вашего класса.

Последняя распространенная ошибка программистов в том, что при переопределении метода equals() не сохраняется соответствие между методами equals() и compareTo(), что является неформальным требованием для избежания хранения дубликатов в Set (SortedSet, TreeSet).

toString метод в Java используется для предоставления ясной и достаточной информации об объекта (Object) в удобном для человека виде. Правильное переопределение метода toString может помочь в ведении журнала работы и в отладке Java программы предоставляя ценную и важную информацию. Поскольку toString() определен в java.lang.Object класса и его реализация по умолчанию не предоставляет много информации, всегда лучшей практикой является переопределение данного метода в классе-потомке.

Фактически, если вы создаете важный или общий класс типа Order, Trade или Employee, всегда переопределяйте equals, hashCode, compareTo и toString методы в Java. По умолчанию реализация toString создает вывод в виде package.class@hashCode, к примеру для нашего примера toString(), toString() метод класса Country напечатает test.Country@18e2b22 где 18e2b22 это хэш-код объекта в шестнадцатеричном виде, если вы вызовете hashCode метод то он вернет 260943370, что является десятеричным эквивалентом 18e2b22. Эта информация не особо полезна во время поиска какой-либо проблемы. Давайте посмотрим на пример из реальной жизни где вам нужно найти проблему в соединении с сетью, в том случае если вы хотите знать с каким именно хостом и портом пытается соединиться ваша система и если Socket или ServerSocket печатает только информацию toString по умолчанию, то будет невозможно представить реальную проблему, но с переопределенной реализацией toString они могут предоставить полезную информацию, такую как имя хоста и номер порта. В этой Java-консультации мы дадим несколько подсказок по переопределению метода toString с примерами кода.

Как переопределить метод toString в Java:
Печать форматированной даты(т.е. день/месяц/год) вместо "сырого" значения. Это очень полезная подсказка при переопределении Java-метода toString. Обычный toString() класса java.util.Date не выводит форматированную дату и включает много деталей, которые не всегда нужны. Если вы используете частичный DateFormat т.е. dd-MM-yy в вашем приложении, то вы определенно хотели бы видеть этот формат вместо данного по умолчанию. IDE обычно не генерирует форматированный вывод Date и это то, что вам нужно сделать самому, но это того стоит. Прочитайте Как распечатать Date в формате ddMMyy в Java где детально описано форматирование Date в Java. Вы так же можете использовать SimpleDataFormat класс или библиотеку Joda Date time для этого.

### 22. Что такое абстрактные классы и методы? Зачем они нужны? Бывают ли случаи, когда абстрактные методы содержат тело? Можно ли в абстрактных классах определять конструкторы? Могут ли абстрактные классы содержать неабстрактные методы? Можно ли от абстрактных классов создавать объекты и почему?

Ты наверняка помнишь, что такое «абстракция» — мы это уже проходили :) Если вдруг подзабыл — не страшно, вспомним: это принцип ООП, согласно которому при проектировании классов и создании объектов необходимо выделять только главные свойства сущности, и отбрасывать второстепенные.

Например, если будем проектировать класс SchoolTeacher — школьный учитель — вряд ли понадобится характеристика «рост». Действительно: для преподавателя эта характеристика не важна. Но вот если мы будем создавать в программе класс BasketballPlayer — игрок в баскетбол — рост станет одной из главных характеристик.

Так вот, абстрактный класс — это максимально абстрактная, о-о-о-чень приблизительная «заготовка» для группы будущих классов. Эту заготовку нельзя использовать в готовом виде — слишком «сырая». Но она описывает некое общее состояние и поведение, которым будут обладать будущие классы — наследники абстрактного класса.

***римеры абстрактных классов Java***

Рассмотрим простой пример с машинами:

    public abstract class Car {
    
    private String model;
    private String color;
    private int maxSpeed;
    
    public abstract void gas();
    
    public abstract void brake();
    
    public String getModel() {
    return model;
    }
    
    public void setModel(String model) {
    this.model = model;
    }
    
    public String getColor() {
    return color;
    }
    
    public void setColor(String color) {
    this.color = color;
    }
    
    public int getMaxSpeed() {
    return maxSpeed;
    }
    
    public void setMaxSpeed(int maxSpeed) {
    this.maxSpeed = maxSpeed;
    }
    }

Вот так выглядит самый простой абстрактный класс. Как видишь, ничего особенного :)

Для чего он может нам понадобиться?

Прежде всего, он максимально абстрактно описывает нужную нам сущность — автомобиль. Слово abstract находится здесь недаром. В мире не существует «просто машин». Есть грузовики, гоночные автомобили, седаны, купе, внедорожники.

Наш абстрактный класс — это просто «чертеж», по которому мы позже будем создавать классы-автомобили.

    public class Sedan extends Car {
    
    @Override
    public void gas() {
    System.out.println("Седан газует!");
    }
    
    @Override
    public void brake() {
    System.out.println("Седан тормозит!");
    }
    
    }

Это во многом похоже на то, о чем мы говорили в лекциях про наследование. Только там у нас класс Car и его методы не были абстрактными. Но у такого решения есть целый ряд минусов, которые в абстрактных классах исправлены.

Первое и главное — экземпляр абстрактного класса создать нельзя:

    public class Main {
    
    public static void main(String[] args) {
    
           Car car = new Car(); // Ошибка! Класс Car является абстрактным!
    }
    }

Эта «фишка» была реализована создателями Java специально. Еще раз, для запоминания: абстрактный класс — это просто чертеж для будущих «нормальных» классов. Тебе же не нужны экземпляры чертежа, правильно? Вот и экземпляры абстрактного класса создавать не надо :)

А если бы класс Car не был абстрактным, мы легко могли бы создавать его объекты:


    public class Car {
    
    private String model;
    private String color;
    private int maxSpeed;
    
    public void gas() {
    // какая-то логика
    }
    
    public  void brake() {
    // какая-то логика
    }
    }
    
    
    public class Main {
    
    public static void main(String[] args) {
    
           Car car = new Car(); // Все ок, машина создалась
    }
    }

Теперь у нас в программе появилась какая-то непонятная машина — не грузовик, не гоночная, не седан, а вообще непонятно что. Та самая «просто машина», которых в природе не существует.

Тот же пример можно привести с животными. Представь, если бы в твоей программе появились объекты Animal — «просто животное». Какого оно вида, к какому семейству относится, какие у него характеристики — непонятно. Было бы странно увидеть его в программе. Никаких «просто животных» в природе не существует. Только собаки, кошки, лисы, кроты и другие.

Абстрактные классы избавляют нас от «просто объектов». Они дают нам базовое состояние и поведение. Например, у всех машин должна быть модель, цвет и максимальная скорость, а еще они должны уметь газовать и тормозить. Вот и все. Это — общая абстрактная схема, дальше ты уже сам проектируешь нужные тебе классы.

Обрати внимание: два метода в абстрактном классе тоже обозначены как abstract, и они вообще не реализованы. Причина та же: абстрактные классы не создают «поведения по умолчанию» для «просто машин». Они просто говорят, что должны уметь делать все машины.

Впрочем, если поведение по умолчанию тебе все-таки нужно, методы в абстрактном классе можно реализовать. Java этого не запрещает:

    public abstract class Car {
    
    private String model;
    private String color;
    private int maxSpeed;
    
    public void gas() {
    System.out.println("Газуем!");
    }
    
    public abstract void brake();
    
    //геттеры и сеттеры
    }
    
    
    public class Sedan extends Car {
    
    @Override
    public void brake() {
    System.out.println("Седан тормозит!");
    }
    
    }
    
    public class Main {
    
    public static void main(String[] args) {
    
           Sedan sedan = new Sedan();
           sedan.gas();
    }
    }

Вывод в консоль:

“Газуем!”

Как видишь, мы реализовали в абстрактном классе один метод, а второй не стали.

В итоге поведение нашего класса Sedan разделилось на две части: если вызвать у него метод gas(), он «подтянется» из родительского абстрактного класса Car, а метод brake() мы переопределили в классе Sedan. Получилось очень удобно и гибко.

Но теперь наш класс не такой уж и абстрактный? Ведь у него, по факту, половина методов реализована.

На самом деле — и это очень важная особенность — класс является абстрактным, если хотя бы один из его методов является абстрактным. Хоть один из двух, хоть один из тысячи методов — без разницы.

Мы можем даже реализовать все методы и не оставить ни одного абстрактного. Будет абстрактный класс без абстрактных методов. В принципе, это возможно, и компилятор не выдаст ошибок, но лучше так не делать: слово abstract потеряет смысл, а твои коллеги-программисты сильно удивятся, увидев такое :/

При этом, если метод помечен словом abstract, каждый класс-наследник должен его реализовать или быть объявленным как абстрактный. Иначе компилятор выбросит ошибку.

Разумеется, каждый класс может наследоваться только от одного абстрактного класса, так что в плане наследования разницы между абстрактными и обычными классами нет. Неважно, наследуемся мы от абстрактного класса или от обычного, класс-родитель может быть только один.


Почему в Java нет множественного наследования классов
Мы уже говорили, что в Java нет множественного наследования, но так толком и не разобрались почему. Давай попробуем сделать это сейчас.

Дело в том, что если бы в Java было множественное наследование, дочерние классы не могли бы определиться, какое именно поведение им выбрать.

Допустим, у нас есть два класса — Toster и NuclearBomb:

    public class Toster {
    
    
    public void on() {
    
           System.out.println("Тостер включен, тост готовится!");
    }
    
    public void off() {
    
           System.out.println("Тостер выключен!");
    }
    }
    
    
    public class NuclearBomb {
    
    public void on() {
    
           System.out.println("Взрыв!");
    }
    }

Как видишь, у обоих есть метод on(). В случае с тостером он запускает приготовление тоста, а в случае с ядерной бомбой — устраивает взрыв.

Ой :/

А теперь представь, что ты решил (уж не знаю, с чего вдруг!) создать что-то среднее между ними. И вот он твой класс — MysteriousDevice!

Этот код, разумеется, нерабочий, и мы приводим его просто в качестве примера «а как оно могло бы быть»:

    public class MysteriousDevice extends Toster, NuclearBomb {
    
    public static void main(String[] args) {
    
           MysteriousDevice mysteriousDevice = new MysteriousDevice();
           mysteriousDevice.on(); // И что же здесь должно произойти? Мы получим тост, или ядерный апокалипсис?
    }
    }

Давай посмотрим, что у нас получилось. Загадочное устройство происходит одновременно и от Тостера, и от Ядерной Бомбы. У обоих есть метод on(), и в результате непонятно, какой из методов on() должен срабатывать у объекта MysteriousDevice, если мы его вызовем. Объект никак не сможет этого понять.

Ну и в качестве вишенки на торте: у Ядерной Бомбы нет метода off(), так что если мы не угадали, отключить устройство будет нельзя.

### 23. Что такое интерфейсы? Как определить и реализовать интерфейс в java-программе? Укажите спецификаторы, которые приобретают методы и поля, определенные в интерфейсе. Можно ли описывать в интерфейсе конструкторы и создавать объекты? Можно ли создавать интерфейсные ссылки и если да, то на какие объекты они могут ссылаться?

Например, интерфейсы есть у большинства компьютерных программ и игр. В широком смысле интерфейс — некий «пульт», который связывает две взаимодействующие друг с другом стороны.

Простой пример интерфейса из повседневной жизни — пульт от телевизора.

Он связывает два объекта, человека и телевизор, и выполняет разные задачи: прибавить или убавить звук, переключить каналы, включить или выключить телевизор.

Одной стороне (человеку) нужно обратиться к интерфейсу (нажать на кнопку пульта), чтобы вторая сторона выполнила действие. Например, чтобы телевизор переключил канал на следующий. При этом пользователю не обязательно знать устройство телевизора и то, как внутри него реализован процесс смены канала.

Все, к чему пользователь имеет доступ — это интерфейс. Главная задача — получить нужный результат.

Какое это имеет отношение к программированию и Java? Прямое :)

Создание интерфейса очень похоже на создание обычного класса, только вместо слова class мы указываем слово interface.

Давай посмотрим на простейший Java-интерфейс, и разберемся, как он работает и для чего нужен:

    public interface Swimmable  {
    
         public void swim();
    }

Мы создали интерфейс Swimmable — «умеющий плавать». Это что-то вроде нашего пульта, у которого есть одна «кнопка»: метод swim()  — «плыть».

Как же нам этот «пульт» использовать?

Для этого метод, т.е. кнопку нашего пульта, нужно имплементировать. Чтобы использовать интерфейс, его методы должны реализовать какие-то классы нашей программы.

Давай придумаем класс, объекты которого подойдут под описание «умеющий плавать». Например, подойдет класс утки — Duck:
    
    public class Duck implements Swimmable {
    
        public void swim() {
            System.out.println("Уточка, плыви!");
        }
    
        public static void main(String[] args) {
    
            Duck duck = new Duck();
            duck.swim();
        }
    }

Что же мы здесь видим?

Класс Duck «связывается» с интерфейсом Swimmable при помощи ключевого слова implements. Если помнишь, мы использовали похожий механизм для связи двух классов в наследовании, только там было слово «extends».

«public class Duck implements Swimmable» можно для понятности перевести дословно: «публичный класс Duck реализует интерфейс Swimmable».

Это значит, что класс, связанный с каким-то интерфейсом, должен реализовать все его методы. Обрати внимание: в нашем классе Duck прямо как в интерфейсе Swimmable есть метод swim(), и внутри него содержится какая-то логика.

Это обязательное требование. Если бы мы просто написали «public class Duck implements Swimmable» и не создали бы метод swim() в классе Duck, компилятор выдал бы нам ошибку:

Duck is not abstract and does not override abstract method swim() in Swimmable

Почему так происходит?

Если объяснять ошибку на примере с телевизором, получится, что мы даем человеку в руки пульт с кнопкой «переключить канал» от телевизора, который не умеет переключать каналы.

Тут уж нажимай на кнопку сколько влезет, ничего не заработает. Пульт сам по себе не переключает каналы: он только дает сигнал телевизору, внутри которого реализован сложный процесс смены канала.

Так и с нашей уткой: она должна уметь плавать, чтобы к ней можно было обратиться с помощью интерфейса Swimmable.

Если она этого не умеет, интерфейс Swimmable не свяжет две стороны — человека и программу. Человек не сможет использовать метод swim(), чтобы заставить объект Duck внутри программы плыть.

Теперь ты увидел более наглядно, для чего нужны интерфейсы.

Интерфейс описывает поведение, которым должны обладать классы, реализующие этот интерфейс. «Поведение» — это совокупность методов.

Если мы хотим создать несколько мессенджеров, проще всего сделать это, создав интерфейс Messenger. Что должен уметь любой мессенджер? В упрощенном виде, принимать и отправлять сообщения.

    public interface Messenger{
    
         public void sendMessage();
    
         public void getMessage();
    }

И теперь мы можем просто создавать наши классы-мессенджеры, имплементируя этот интерфейс. Компилятор сам «заставит» нас реализовать их внутри классов.

Telegram:
    
    public class Telegram implements Messenger {
    
        public void sendMessage() {
    
            System.out.println("Отправляем сообщение в Telegram!");
        }
    
         public void getMessage() {
             System.out.println("Читаем сообщение в Telegram!");
         }
    }

Какие преимущества это дает? Самое главное из них — слабая связанность.

Представь, что мы проектируем программу, в которой у нас будут собраны данные клиентов. В классе Client обязательно нужно поле, указывающее, каким именно мессенджером клиент пользуется.

Без интерфейсов это выглядело бы странно:

    public class Client {
    
        private WhatsApp whatsApp;
        private Telegram telegram;
        private Viber viber;
    }

Мы создали три поля, но у клиента запросто может быть всего один мессенджер. Просто мы не знаем какой. И чтобы не остаться без связи с клиентом, приходится «заталкивать» в класс все возможные варианты. Получается, один или два из них всегда будут null, и они вообще не нужны для работы программы.

Вместо этого лучше использовать наш интерфейс:

    public class Client {
    
        private Messenger messenger;
    }

Это и есть пример «слабой связанности»! Вместо того, чтобы указывать конкретный класс мессенджера в классе Client, мы просто упоминаем, что у клиента есть мессенджер. Какой именно — определится в ходе работы программы.

Но зачем нам для этого именно интерфейсы? Зачем их вообще добавили в язык?

Вопрос хороший и правильный! Того же результата можно добиться с помощью обычного наследования, так ведь?

Класс Messenger — родительский, а Viber, Telegram и WhatsApp — наследники. Действительно, можно и так.

Но есть одна загвоздка. Как ты уже знаешь, множественного наследования в Java нет. А вот множественная реализация интерфейсов — есть. Класс может реализовывать сколько угодно интерфейсов.

Представь, что у нас есть класс Smartphone, у которого есть поле Application — установленное на смартфоне приложение.

    public class Smartphone {
    
        private Application application;
    }

Приложение и мессенджер, конечно, похожи, но все-таки это разные вещи. Мессенджер может быть и мобильным, и десктопным, в то время как Application — это именно мобильное приложение.

Так вот, если бы мы использовали наследование, не смогли бы добавить объект Telegram в класс Smartphone. Ведь класс Telegram не может наследоваться одновременно от Application и от Messenger! А мы уже успели унаследовать его от Messenger, и в таком виде добавить в класс Client.

Но вот реализовать оба интерфейса класс Telegram запросто может!  Поэтому в классе Client мы сможем внедрить объект Telegram как Messenger, а в класс Smartphone — как Application. Вот как это делается:

    public class Telegram implements Application, Messenger {
    
        //...методы
    }
    
    public class Client {
    
        private Messenger messenger;
    
        public Client() {
            this.messenger = new Telegram();
        }
    }
    
    
    public class Smartphone {
    
        private Application application;
    
        public Smartphone() {
            this.application = new Telegram();
        }
    }

Теперь мы используем класс Telegram как захотим. Где-то он будет выступать в роли Application, где-то — в роли Messenger.

Наверняка ты уже обратил внимание, что методы в интерфейсах всегда «пустые», то есть они не имеют реализации.

Причина этого проста: интерфейс описывает поведение, а не реализует его.

«Все объекты классов, имплементирующих интерфейс Swimmable, должны уметь плавать»: вот и все, что говорит нам интерфейс. Как там конкретно будет плавать рыба, утка или лошадь — вопрос к классам Fish, Duck и Horse, а не к интерфейсу. Также как переключение канала — задача телевизора. Пульт просто предоставляет тебе кнопку для этого.

Впрочем, в Java8 появилось интересное дополнение — методы по умолчанию (default method).

Например, в твоем интерфейсе есть 10 методов. 9 из них реализованы по-разному в разных классах, но один реализован одинаково у всех. Раньше, до выхода Java8, методы внутри интерфейсов вообще не имели реализации: компилятор сразу выдавал ошибку. Теперь же можно сделать вот так:

    public interface Swimmable {
    
    public default void swim() {
    System.out.println("Плыви!");
    }
    
    public void eat();
    
    public void run();
    }

Используя ключевое слово default, мы создали в интерфейсе метод с реализацией по умолчанию. Два других метода, eat() и run(), нам необходимо будет реализовать самим во всех классах, которые будут имплементировать Swimmable. С методом swim() этого делать не нужно: реализация будет во всех классах одинаковой.

примеры:

![](https://cdn.javarush.ru/images/article/dd15b9e7-137d-45f1-8233-51f18c9a41a6/1024.webp)

### 24. Для чего служит интерфейс Clonable? Как правильно переопределить метод clone() класса Object, для того, что объект мог создавать свои адекватные копии?

Интерфейс Cloneable – это так называемый интерфейс-маркер, который не содержит никаких методов. Он используется, чтобы маркировать (помечать) некоторые классы.

Если разработчик класса считает, что объекты класса можно клонировать, он помечает класс этим интерфейсом (наследует класс от Cloneable).

если ты хочешь воспользоваться «клонированием по умолчанию», которое реализовано в классе Object, тебе нужно:

а) Добавить интерфейс Cloneable своему классу

б) Переопределить метод clone и вызвать в нем базовую реализацию:

    class Point implements Cloneable
    {
    int x;
    int y;
    
    public Object clone()
    {
    return super.clone();
    }
    }

Или ты можешь написать реализацию метода clone полностью сам:

    class Point
    {
    int x;
    int y;
    
    public Object clone()
    {
    Point point = new Point();
    point.x = this.x;
    point.y = this.y;
    return point;
    }
    }

### 25. Для чего служат интерфейсы Comparable и Comparator? В каких случаях предпочтительнее использовать первый, а когда – второй? Как их реализовать и использовать?

***Comparator и Comparable в Java***

Что же нам подходит? Если мы в переводчике переведём слово "сравнить" на английский, то получим перевод "compare". Отлично, значит нам нужен тот, кто будет сравнивать. Если сравнивать это compare, то тот, кто сравнивает - Comparator. Откроем Java Api и найдём там Comparator.

И действительно, есть такой интерфейс — java.util.Comparator

java.util.Comparator и java.lang.Comparable

Как видно, существует такой такой интерфейс. Класс, который его реализует говорит этим, что "Я реализую функцию сравнения объектов".
Единственное, что надо действительно запомнить - это контракт компаратора, который выражается в следующем:

    Comparator возвращает int по следующей схеме:
    отрицательный int (первый объект отрицательный, то есть меньше)
    положительный int (первый объект положительный, хороший, то есть больший)
    ноль = объекты равны

Теперь напишем компаратор. Нам потребуется импорт java.util.Comparator. После импорта добавим в main метод:

    Comparator<Message> comparator = new Comparator<Message>();

Естественно, это не отработает, т.к. Comparator это интерфейс. Поэтому, после круглых скобок добавим фигурные { }.

В этих скобках напишем метод:

    public int compare(Message o1, Message o2) {
    return o1.getId().compareTo(o2.getId());
    }

Написание это не надо даже помнить. Компаратор - это тот, кто выполняет сравнивание, то есть делает compare. Чтобы ответить на вопрос, в каком порядке идут сравниваемые объекты мы возвращаем int. Вот и всё, собсвтенно. Легко и просто.

Как мы видим из примера, помимо Comparator'а есть ещё один интерфейс — java.lang.Comparable, реализуя который мы должны определить метод compareTo. Данный интерфейс говорит, что "Класс, который реализует интерфейс, позволяет сравнивать экземпляры класса". Например, у Integer реализация compareTo выглядит следующим образом:

    (x < y) ? -1 : ((x == y) ? 0 : 1)

Как запомнить все эти интерфейсы? А зачем? Всё идёт от английского. Compare - сравнивать, тот кто сравнивает — Comparator (как регистратор, например. Т.е. тот, кто регистрирует), а прилагательное "сравниваемое" Comparable. Ну а "Сравнить с" переводится не только как compare with, но и как compare to. Всё просто. Язык Java писали ведь англоговорящие люди и в названии всего в Java они руководствовались просто английским и в именовании была какая-то логика. А метод compareTo описывает то, каким образом экземпляр класса нужно сравнивать с другими экземплярами. Например, строки сравниваются лексиграфически, а числа сравниваются по значению.

Java 8 внесла приятные изменения. Если приглядеться к интерфейсу Comparator, то мы увидим, что над ним стоит аннотация @FunctionalInterface. На самом деле, эта аннотация для информации и означает, что данный интерфейс является функциональным.
Это значит, что в этом интерфейсе есть всего 1 абстрактный метод без реализации. Что это нам даёт?

Мы можем написать код компаратора теперь вот так:

    Comparator<Message> comparator = (o1, o2) -> o1.getId().compareTo(o2.getId());

В скобочках — то, как мы назовём переменные. Java сама увидит, что т.к. метод то всего один, то понятно какие входные параметры нужны, сколько, каких типов. Далее мы говорим стрелочкой, что хотим их передать вот в этот участок кода.

Кроме того, благодаря Java 8 появились default методы в интерфейсах - это такие методы, которые по умолчанию появляются (по умолчанию - by default), когда мы реализуем интерфейс. В интерфейсе Comparator таких несколько.Например:

    Comparator moreImportant = Comparator.reverseOrder();
    Comparator lessImportant = Comparator.naturalOrder();

Есть и ещё один метод, который сделает ваш код чище. Посмотрим на пример выше, где мы описывали наш компаратор. Что он делает? Он ведь довольно примитивный. Он просто берёт объект и достаёт из него какое-то значение, которое comparable. Например, Integer реализует comparable, поэтому мы смогли выполнить compareTo на значениях id сообщения. Эту простую функцию компаратора можно записать и так:

    Comparator<Message> comparator = Comparator.comparing(obj -> obj.getId());

То есть дословно "У нас есть Comparator, сравнивающий так: берёт объекты, достаёт из них Comparable при помощи метода getId(), сравнивает через compareTo". И никаких ужасных конструкций больше.

Ну и напоследок, хочется ещё отметить одну особенность. Компараторы можно объединять в цепочку. Например:

    Comparator<Message> comparator = Comparator.comparing(obj -> obj.getId());
    comparator = comparator.thenComparing(obj -> obj.getMessage().length());

***Применение***

Объявление компаратора оказалось довольно логичным, не правда ли? Теперь надо посмотреть, как же его использовать и в каких местах.

→ Collections.sort (java.util.Collections)

Конечно же, мы можем сортировать коллекции таким образом. Но не все, а только списки. И тут нет ничего необычного, т.к. именно список предполагает доступ к элементу по индексу. А это позволяет элемент номер два поменять местами с элементом номер три. Поэтому и сортировка таким образом есть только для списков:

    Comparator<Message> comparator = Comparator.comparing(obj -> obj.getId());
    Collections.sort(messages, comparator);

Arrays.sort (java.util.Arrays)

Массивы так же удобно сортировать. Опять, по той же самое причине доступа к элементам по индексу.

→ Наследники java.util.SortedSet и java.util.SortedMap

Как мы помним, у Set и Map не гарантируют порядок хранения записей. НО у нас есть специальные реализации, которые гарантируют порядок.
И если элементы коллекции не реализуют java.lang.Comparable, то мы в конструктор таких коллекций можем передать Comparator:


    Set<Message> msgSet = new TreeSet(comparator);

→ Stream API

В Stream Api, которые появились в Java 8, компаратор позволяет упрощать работу над элементами стримов.

Например, нам нужна последовательность случайных чисел от 0 до 999 включительно:

    Supplier<Integer> randomizer = () -> new Random().nextInt(1000);
    Stream.generate(randomizer)
    .limit(10)
    .sorted(Comparator.naturalOrder())
    .forEach(e -> System.out.println(e));

Мы могли бы и остановиться, но есть задачки поинтереснее. Например, нужно подготовить Map, где ключ — id сообщения.
При этом мы хотим отсортировать эти ключи, чтобы ключи шли по порядку, от меньшего к большему.

Начнём с такого кода:

    Map<Integer, Message> collected = Arrays.stream(messages)
    .sorted(Comparator.comparing(msg -> msg.getId()))
    .collect(Collectors.toMap(msg -> msg.getId(), msg -> msg));

Нам вернут тут на самом деле HashMap. А как мы знаем, она не гарантирует какой либо порядок. Поэтому наши отсортированные по ID записи просто потеряли порядок. Не хорошо. Придётся изменить немного наш коллектор:

    Map<Integer, Message> collected = Arrays.stream(messages)
    .sorted(Comparator.comparing(msg -> msg.getId()))
    .collect(Collectors.toMap(msg -> msg.getId(), msg -> msg, (oldValue, newValue) -> oldValue, TreeMap::new));

Код стал выглядеть несколько страшнее, но задача теперь решена правильно благодаря явному указанию реализации карты TreeMap.

Comparator и Comparable это хорошо. Но с ними связан один нюанс, про который стоит помнить. Когда класс выполняет сортировку, то он рассчитывает, что можно привести Ваш класс к Comparable. Если это не так - в момент выполнения вы получите ошибку. Посмотрим на пример:

    SortedSet<Message> msg = new TreeSet<>();
    msg.add(new Message(2, "Developer".getBytes()));

Кажется, что ничего плохого тут нет. Но на самом деле на нашем примере он упадёт с ошибкой:

java.lang.ClassCastException: Message cannot be cast to java.lang.Comparable

А всё потому, что он пытался отсортировать элементы (Он ведь SortedSet). И не смог.

Cледует не забыть про это при работе с SortedMap и SortedSet.


## Generic classes and Interfaces, Enums

### 1. Что такое перечисления в Java. Как объявить перечисление? Чем являются элементы перечислений? Кто и когда создает экземпляры перечислений?

С выходом Java 1.5 в языке появилось готовое решение для таких ситуаций — перечисление Enum.

Enum — тоже класс. Но он специально «заточен» на решение задач, похожих на нашу: создание некоторого ограниченного круга значений.

Поскольку у создателей Java уже были готовые примеры (скажем, язык С, в котором Enum уже существовал), они смогли создать оптимальный вариант.

***Давай посмотрим на примере того же DayOfWeek:***

    public enum DayOfWeek {
    
    SUNDAY,
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY
    }

Внутри нашего Enum находятся 7 констант со статическим доступом. Мы уже можем его использовать для реализации логики в программе.

Например, напишем программу, которая будет определять, нужно ли школьнику сегодня идти на учебу. У нашего школьника будет свой режим дня, обозначенный классом ScholarSchedule:

    public class ScholarSchedule {
    
    private DayOfWeek dayOfWeek;
    //...другие поля
    
    
    public DayOfWeek getDayOfWeek() {
    return dayOfWeek;
    }
    
    public void setDayOfWeek(DayOfWeek dayOfWeek) {
    this.dayOfWeek = dayOfWeek;
    }
    }

Переменная dayOfWeek в режиме дня определяет, какой сегодня день.

А вот класс нашего школьника:

    public class Scholar {
    
    private ScholarSchedule schedule;
    private boolean goToSchool;
    
    public void wakeUp() {
    
           if (this.schedule.getDayOfWeek() == DayOfWeek.SUNDAY) {
               System.out.println("Ура, можно поспать еще!");
           } else {
               System.out.println("Блин, опять в школу:(");
           }
    }
    }

В методе wakeUp() при помощи Enum определяем дальнейшие действия школьника.

Мы даже не описывали подробно, что значит каждая переменная в DayOfWeek, да это и не нужно: механизм дней недели и так очевиден, и если мы будем его использовать в текущем виде, любому разработчику будет понятно, что происходит в твоем коде.

Еще один пример удобства Enum: его константы можно использовать с оператором switch. Например, мы пишем программу для строгой диеты, в которой блюда расписаны по дням:


    public class VeryStrictDiet {
    
    public void takeLunch(DayOfWeek dayOfWeek) {
    
           switch (dayOfWeek) {
    
               case SUNDAY:
                   System.out.println("Воскресный обед! Сегодня можно даже немного сладкого");
               case MONDAY:
                   System.out.println("Обед для понедельника: куриная лапша!");
               case TUESDAY:
                   System.out.println("Вторник, сегодня суп из сельдерея :(");
                   //...и так далее до конца
           }
    }

Это одно из преимуществ Enum перед старым решением, которое применялось до Java 1.5: старое решение нельзя было использовать со switch.

Enum — это настоящий класс со всеми вытекающими из этого возможностями.

Например, если текущей реализации дней недели тебе недостаточно, ты можешь добавить в DayOfWeek переменные, конструкторы и методы:

    public enum DayOfWeek {
    
    SUNDAY ("Воскресенье"),
    MONDAY ("Понедельник"),
    TUESDAY ("Вторник"),
    WEDNESDAY ("Среда"),
    THURSDAY ("Четверг"),
    FRIDAY ("Пятница"),
    SATURDAY ("Суббота");
    
    private String title;
    
    DayOfWeek(String title) {
    this.title = title;
    }
    
    public String getTitle() {
    return title;
    }
    
    @Override
    public String toString() {
    return "DayOfWeek{" +
    "title='" + title + '\'' +
    '}';
    }
    }

Теперь у констант нашего Enum есть поле title, геттер и переопределенный метод toString.

По сравнению с обычными классами, на Enum наложили одно серьезное ограничение — от него невозможно наследоваться.

Кроме того, у перечислений есть характерные только для них методы:
values(): возвращает массив из всех хранящихся в Enum значений:

    public static void main(String[] args) {
    System.out.println(Arrays.toString(DayOfWeek.values()));
    }

Вывод:

[DayOfWeek{title='Воскресенье'}, DayOfWeek{title='Понедельник'}, DayOfWeek{title='Вторник'}, DayOfWeek{title='Среда'}, DayOfWeek{title='Четверг'}, DayOfWeek{title='Пятница'}, DayOfWeek{title='Суббота'}]

ordinal(): возвращает порядковый номер константы. Отсчет начинается с нуля:

    public static void main(String[] args) {
    
            int sundayIndex = DayOfWeek.SUNDAY.ordinal();
            System.out.println(sundayIndex);
    }

Вывод:

0

valueOf(): возвращает объект Enum, соответствующий переданному имени:

Вывод:

DayOfWeek{title='Воскресенье'}

Обрати внимание: мы указываем названия элементов Enum прописными буквами, поскольку это константы, а для них предусмотрена именно такая запись, а не camelCase.

### 2. Можно ли самостоятельно создать экземпляр перечисления? А ссылку типа перечисления? Как сравнить, что в двух переменных содержится один и тот же элемент перечисления и почему именно так?

Можно.

***Пример:***

    public class DayOfWeek {
    
    private String title;
    
    private DayOfWeek(String title) {
    this.title = title;
    }
    
    public static DayOfWeek SUNDAY = new DayOfWeek("Воскресенье");
    public static DayOfWeek MONDAY = new DayOfWeek("Понедельник");
    public static DayOfWeek TUESDAY = new DayOfWeek("Вторник");
    public static DayOfWeek WEDNESDAY = new DayOfWeek("Среда");
    public static DayOfWeek THURSDAY = new DayOfWeek("Четверг");
    public static DayOfWeek FRIDAY = new DayOfWeek("Пятница");
    public static DayOfWeek SATURDAY = new DayOfWeek("Суббота");
    
    @Override
    public String toString() {
    return "DayOfWeek{" +
    "title='" + title + '\'' +
    '}';
    }
    }

На что тут стоит обратить внимание:
Приватный конструктор. Если конструктор помечен модификатором private, объект класса нельзя создать с помощью этого конструктора. А поскольку в этом классе конструктор всего один, объект DayOfWeek нельзя создать вообще.

    public class Main {
    
            public static void main(String[] args) {
    
                    DayOfWeek sunday = new DayOfWeek();//ошибка!
            }
    }

При этом в классе содержалось нужное количество public static объектов, которые были инициализированы нужным нам образом (названия дней правильные).

Это позволяло использовать объекты в других классах.

    public class Man {
    
            public static void main(String[] args) {
    
                    DayOfWeek sunday = DayOfWeek.SUNDAY;
    
                    System.out.println(sunday);
             }
    }

Вывод:

DayOfWeek{title='Воскресенье'}

Такой подход во многом позволял решить задачу. В нашем распоряжении были 7 дней недели, и при этом никто не мог создать новые.



### 3. Что такое анонимные классы?


![рисунок 4](https://cdn.javarush.ru/images/article/70d01355-803c-4aad-a8cb-19da0a4023f6/800.webp)

Как и локальные классы, о которых мы говорили в прошлой лекции, анонимные —подвид внутренних классов. У них также есть несколько сходств и отличий между собой.

Но для начала давай разберемся: а почему они, собственно, называются «анонимными»?

Для этого рассмотрим простой пример.

Представь, что у нас есть основная программа, которая постоянно работает и что-то делает. Мы хотим создать для этой программы систему мониторинга из нескольких модулей.

Один модуль будет отслеживать общие показатели работы и вести лог, второй — фиксировать и регистрировать ошибки в журнале ошибок, третий — отслеживать подозрительную активность: например, попытки несанкционированного доступа и прочие связанные с безопасностью вещи.

Поскольку все три модуля должны, по сути, просто стартовать в начале программы и работать в фоновом режиме, будет хорошей идеей создать для них общий интерфейс:

    public interface MonitoringSystem {
    
    public void startMonitoring();
    }

Его будут имплементировать 3 конкретных класса:


    public class GeneralIndicatorsMonitoringModule implements MonitoringSystem {
    
    @Override
    public void startMonitoring() {
    System.out.println("Мониторинг общих показателей стартовал!");
    }
    }
    
    
    public class ErrorMonitoringModule implements MonitoringSystem {
    
    @Override
    public void startMonitoring() {
    System.out.println("Мониторинг отслеживания ошибок стартовал!");
    }
    }
    
    
    public class SecurityModule implements MonitoringSystem {
    
    @Override
    public void startMonitoring() {
    System.out.println("Мониторинг безопасности стартовал!");
    }
    }

Казалось бы, все в порядке. У нас есть довольно внятная система из нескольких модулей. У каждого из них есть собственное поведение. Если нам понадобятся новые модули, мы сможем их добавить, ведь у нас есть интерфейс, который достаточно легко имплементировать.

Но давай подумаем о том, как будет работать наша система мониторинга.

По сути, мы должны просто создать 3 объекта — GeneralIndicatorsMonitoringModule, ErrorMonitoringModule, SecurityModule — и вызвать метод startMonitoring() у каждого из них.

То есть, все, что нужно сделать — создать 3 объекта и вызвать у них 1 метод.

    public class Main {
    
    public static void main(String[] args) {
    
           GeneralIndicatorsMonitoringModule generalModule = new GeneralIndicatorsMonitoringModule();
           ErrorMonitoringModule errorModule = new ErrorMonitoringModule();
           SecurityModule securityModule = new SecurityModule();
    
           generalModule.startMonitoring();
           errorModule.startMonitoring();
           securityModule.startMonitoring();
    }
    }


Вывод в консоль:

Мониторинг общих показателей стартовал!
Мониторинг отслеживания ошибок стартовал!
Мониторинг безопасности стартовал!

И для такой небольшой работы мы написали целую систему: 3 класса и один интерфейс! И все это — ради 6 строк кода.

С другой стороны, какие у нас варианты?

Да, не очень здорово, что мы понаписали таких вот «одноразовых» классов. Но как мы можем это исправить?

Здесь нам и приходят на помощь анонимные внутренние классы!

Вот как они выглядят в нашем случае:

    public class Main {

    public static void main(String[] args) {
    
           MonitoringSystem generalModule = new MonitoringSystem() {
               @Override
               public void startMonitoring() {
                   System.out.println("Мониторинг общих показателей стартовал!");
               }
           };
    
    
    
    MonitoringSystem errorModule = new MonitoringSystem() {
    @Override
    public void startMonitoring() {
    System.out.println("Мониторинг отслеживания ошибок стартовал!");
    }
    };
    
           MonitoringSystem securityModule = new MonitoringSystem() {
               @Override
               public void startMonitoring() {
                   System.out.println("Мониторинг безопасности стартовал!");
               }
           };
    
           generalModule.startMonitoring();
           errorModule.startMonitoring();
           securityModule.startMonitoring();
    }
    }

Давай разбираться, что тут происходит!

Выглядит так, как будто мы создаем объект интерфейса:

    MonitoringSystem generalModule = new MonitoringSystem() {
    
    @Override
    public void startMonitoring() {
    System.out.println("Мониторинг общих показателей стартовал!");
    }
    };

Но ведь мы давно знаем, что создавать объекты интерфейсов нельзя!

Так и есть, нельзя. На самом деле мы этого и не делаем.

В тот момент, когда мы пишем:

    MonitoringSystem generalModule = new MonitoringSystem() {
    
    };

***внутри Java-машины происходит следующее:***

1. Создается безымянный Java-класс, реализующий интерфейс MonitoringSystem.
2. Компилятор, увидев такой класс, требует от тебя реализовать все методы интерфейса MonitoringSystem (мы это и сделали 3 раза).
3. Создается один объект этого класса. Обрати внимание на код:

    MonitoringSystem generalModule = new MonitoringSystem() {
    
    };

В конце стоит точка с запятой! Она стоит там не просто так. Мы одновременно объявляем класс (посредством фигурных скобок) и создаем его объект с помощью ();

Каждый из наших трех объектов переопределил метод startMonitoring() по-своему.

В конце мы просто вызываем этот метод у каждого из них:

    generalModule.startMonitoring();
    errorModule.startMonitoring();
    securityModule.startMonitoring();

Вывод в консоль:

Мониторинг общих показателей стартовал!
Мониторинг отслеживания ошибок стартовал!
Мониторинг безопасности стартовал!

Вот и все! Мы выполнили свою задачу: создали три объекта MonitoringSystem, переопределили его тремя разными способами и вызвали трижды.

Все три модуля успешно запущены и работают.

При этом структура нашей программы стала намного проще! Ведь классы GeneralIndicatorsMonitoringModule, ErrorMonitoringModule, SecurityModule теперь вообще можно удалить из программы!

Они нам просто не нужны — мы прекрасно справились и без них.
Если каждому из наших анонимных классов-модулей понадобится какое-то отличающееся поведение, свои специфические методы, которых нет у других, мы легко можем дописать их:

    MonitoringSystem generalModule = new MonitoringSystem() {
    
    @Override
    public void startMonitoring() {
    System.out.println("Мониторинг общих показателей стартовал!");
    }
    
    public void someSpecificMethod() {
    
           System.out.println("Специфический метод только для первого модуля");
    }
    };

В документации Oracle приведена хорошая рекомендация: «Применяйте анонимные классы, если вам нужен локальный класс для одноразового использования».

Анонимный класс — это полноценный внутренний класс. Поэтому у него есть доступ к переменным внешнего класса, в том числе к статическим и приватным:

    public class Main {
    
    private static int currentErrorsCount = 23;
    
    public static void main(String[] args) {
    
           MonitoringSystem errorModule = new MonitoringSystem() {
    
               @Override
               public void startMonitoring() {
                   System.out.println("Мониторинг отслеживания ошибок стартовал!");
               }
    
               public int getCurrentErrorsCount() {
    
                   return currentErrorsCount;
               }
           };
    }
    }

Есть у них кое-что общее и с локальными классами: они видны только внутри того метода, в котором определены. В примере выше, любые попытки обратиться к объекту errorModule за пределами метода main() будут неудачными.

И еще одно важное ограничение, которое досталось анонимным классам от их «предков» — внутренних классов: анонимный класс не может содержать статические переменные и методы.

Если мы попробуем сделать метод getCurrentErrorsCount() из примера выше статическим, компилятор выбросит ошибку:

    //ошибка! Inner classes cannot have static declarations
    public static int getCurrentErrorsCount() {
    
    return currentErrorsCount;
    }

Тот же результат мы получим, если попробуем объявить статическую переменную:
    
    MonitoringSystem errorModule = new MonitoringSystem() {
    
    //ошибка! Inner classes cannot have static declarations!
    static int staticInt = 10;
    
    @Override
    public void startMonitoring() {
    System.out.println("Мониторинг отслеживания ошибок стартовал!");
    }
    
    };


### 4. Что такое параметризованные классы? Для чего они необходимы? Приведите пример параметризованного класса и пример создания объекта параметризованного класса? Объясните, ссылки какого типа могут ссылаться на объекты параметризованных классов? Можно ли создать объект, параметризовав его примитивным типом данных?

Параметризованные типы позволяют объявлять классы, интерфейсы и методы, где тип данных, которыми они оперируют, указан в виде параметра. Используя дженерики, можно создать единственный класс, например, который будет автоматически работать с разными типами данных.

Все классы в Java неявно (скрытно) унаследованы от класса Object.

Что такое наследование и как оно работает в Java, мы разберем в квесте Java Core. Сейчас же мы рассмотрим один простой факт, который из этого следует:

Переменной типа Object можно присвоить объект любого класса. Пример:

* Object o = new Scanner(System.in);

* Object o = new String();

* Object o = new Integer(15);

На этом хорошие новости заканчиваются. Компилятор не следит за тем, объект какого именно типа был сохранен в переменную типа Object, поэтому вызвать методы, которые были у сохраненного объекта, но которых нет у переменной типа Object нельзя.

Если нужно вызвать методы такого объекта, то сначала ссылку на него нужно сохранить в переменную правильного типа, а только потом вызвать методы у этой переменной:

    Object o = new Scanner(System.in);  

    int x = o.nextInt();

Программа не скомпилируется. У класса Object нет метода nextInt().

    Object o = new Scanner(System.in);
    
    Scanner console = (Scanner) o;
    
    int x = console.nextInt();

Так будет работать.

Тут мы сохраняем ссылку на объект типа Scanner в переменную типа Scanner с помощью оператора приведения типа.

Просто так переменную типа Object нельзя присвоить переменной типа Scanner, даже если переменная типа Object хранит ссылку на объект типа Scanner. Зато это можно сделать, если использовать уже известный вам оператор приведения типа. В общем виде выглядит это так:

    Тип имя1 = (Тип) имя2;

Где имя1 – это имя переменной типа Тип, а имя2 – это имя переменной типа Object, которая хранит ссылку на объект типа Тип.


Приведение типа

Если типы переменной и объекта не совпадают, возникнет ошибка ClassCastException. Пример:

    Object o = new Integer(5);
    String s = (String) o;

Во время выполнения возникнет ошибка:
тут кинется исключение ClassCastException

В Java есть способ обойти эту ошибку: существует способ проверить, какой на самом деле тип находится внутри переменной:

    имя instanceof Тип

Оператор instanceof проверяет, является ли переменная имя объектом типа Тип.

Пример — нахождение строки среди массива данных:

    Object[] objects = {10, "Привет", 3.14};
    
    for (int i = 0; i < objects.length; i++)
    {
    if (objects[i] instanceof String)
    {
    String s = (String) objects[i];
    System.out.println(s);
    }
    }
utoboxing превратит эти значения в Integer, String и Double.

Цикл по массиву объектов

Если объект имеет тип String

Сохраняем его в переменную типа String
Выводим переменную на экран.

***Причина возникновения шаблонов (коллекции)***

Возвращаемся к коллекциям.

Когда Java-разработчики только создавали класс ArrayList, они хотели сделать его универсальным, чтобы в нем можно было хранить объекты любого типа. Поэтому для хранения элементов они воспользовались массивом типа Object.

Сильная сторона такого подхода в том, что в коллекцию можно добавить объект любого типа.

Ну а слабых сразу несколько.

***Недостаток 1.***

Всегда приходилось писать оператор преобразования типа, когда доставали элементы из коллекции:

    ArrayList numbers = new ArrayList();
    
    
    for (int i = 0; i < 10; i++)
    numbers.add(i * 10);
    
    
    int sum = 0;
    for (int i = 0; i < 10; i++)
    {
    sum = sum + (Integer) numbers.get(i);
    }

Создаем объект-коллекцию для хранения ссылок на объекты типа Object

Заполняем коллекцию цифрами 10, 20, ... 100;

Суммируем элементы коллекции

Нужно использовать приведение типа

***Недостаток 2.***

Не было гарантии, что в коллекции хранятся элементы определенного типа

    ArrayList numbers = new ArrayList();
    
    
    for (int i = 0; i < 10; i++)
    numbers.add(i * 2.5);
    
    
    int sum = 0;
    for (int i = 0; i < 10; i++)
    {
    sum = sum + (Integer) numbers.get(i);
    }

Создаем объект-коллекцию для хранения ссылок на объекты типа Object

Заполняем коллекцию числами типа Double:
0.0, 2.5, 5.0, ...
Суммируем элементы коллекции
Будет ошибка: тип Double нельзя привести к типу Integer

Данные в коллекцию могут заполняться где угодно:

в другом методе
в другой программе
загружаться из файла
получаться по сети


***Недостаток 3.***

Данные коллекции можно случайно поменять по незнанию.

Вы можете передать коллекцию, заполенную вашими данными в какой-то метод, а этот метод, написанный совсем другим программистом, добавит в вашу коллекцию свои данные.

По названию коллекции непонятно, какие именно типы данных можно в ней хранить. А даже если и дать переменной такое название, ссылку на нее можно передать в десяток методов, и уж там-то точно об изначальном имени переменной ничего не будет известно.

Все эти проблемы устраняет такая классная вещь в Java как дженерики (Generics).

Под дженериками в Java подразумевают возможность добавлять к типам типы-параметры. Таким образом получаются сложные составные типы. Такой составной тип в общем случае выглядит так:

    ОсновнойТип<ТипПараметр>

Все вместе — это именно тип. И он может использоваться там, где обычно можно использовать типы.

    ArrayList<Integer> list;

Создание переменных

    list = new ArrayList<Integer> ();

Создание объектов

    ArrayList<Integer>[] array;

Создание массивов


В такую коллекцию можно сохранить только переменные типа Integer:

    ArrayList<Integer> list = new ArrayList<Integer>();
    list.add(new Integer(1));
    list.add(2);
    list.add("Привет");

Коллекция типа ArrayList с элементами типа Integer
Так можно
И так можно: сработает autoboxing
А так нельзя: ошибка компиляции

Как создавать свои классы с типами-параметрами, вы изучите в квесте Java Collections. Сейчас же мы разберем, как этим пользоваться и как это работает.


***Как работают Generics***

На самом деле Generics работают до ужаса примитивно.

Компилятор просто заменяет тип с параметром на него же, только без параметра. А при взаимодействии с его методами добавляет операцию приведения типа к типу-параметру:

    ArrayList<Integer> list = new ArrayList<Integer>();

***Что сделает компилятор***

    ArrayList list = new ArrayList();

    list.add(1);

***Что сделает компилятор***

    list.add( (Integer) 1 );

    int x = list.get(0);
***Что сделает компилятор***

    int x = (Integer) list.get(0);

    list.set(0, 10);

***Что сделает компилятор***

    list.set(0, (Integer) 10);

Допустим, у нас был код метода, который суммирует числа в коллекции целых чисел:

    public int sum(ArrayList<Integer> numbers)
    {
    int result = 0;
    
    for (int i = 0; i < numbers.size(); i++)
    result = result + numbers.get(i);
    
    return result;
    }
***Что сделает компилятор***

    public int sum(ArrayList numbers)
    {
    int result = 0;
    
    for (int i = 0; i < numbers.size(); i++)
    result = result + (Integer) numbers.get(i);
    
    return result;
    }

Т.е. по сути дженерики — это такая разновидность синтаксического сахара, как и autoboxing, только побольше. При autoboxing компилятор за нас добавляет методы для преобразования типа int к Integer и обратно, а для generics добавляет операторы приведения типа.

После того, как компилятор скомпилировал ваш код с дженериками, в нем все классы с параметрами были преобразованы просто в классы и операторы приведения типа. Информация о том, какие изначально были типы-параметры у переменных сложных типов, потерялась. Этот эффект еще называют стиранием типов.

Иногда программистам, которые пишут свои классы с типами-параметрами, очень нехватает информации о типах, которые туда передаются в качестве параметров. Как с этим борются и что из этого выходит, вы узнаете в квесте Java Collections.

Еще несколько интересных фактов о дженериках.

У классов может быть не один тип параметр, а несколько. Выглядит это примерно так:

    ОсновнойТип<ТипПараметр1, ТипПараметр2, ТипПараметр3>

Собственно говоря, в этом нет ничего удивительного. Там, где компилятор может добавить оператор приведения к одному типу, он может добавить и несколько таких.

***Примеры:***

    HashMap<Integer, String> map = new HashMap<Integer, String>();
    map.put(7, "Привет");
    map.put(-15, "Привет");

первый параметр метода put имеет тип Integer, второй — тип String

Также сложные типы тоже можно использовать в качестве параметров. Выглядит это примерно так:

    ОсновнойТип<ТипПараметр<ТипПараметрПараметра>>

Допустим, мы хотим создать список, который будет хранить списки строк. В таком случае мы получим примерно такой код:

    // список приветствий
    ArrayList<String> listHello = new ArrayList<String>();
    listHello.add("Привет");
    listHello.add("Hi");
    
    // список прощаний
    ArrayList<String> listBye = new ArrayList<String>();
    listBye.add("Пока");
    listBye.add("Good Bye");
    
    // список списков
    ArrayList<ArrayList<String>> lists = new ArrayList<ArrayList<String>>();
    lists.add(listHello);
    lists.add(listBye);

Так же сложные типы (типы с параметрами) можно использовать в качестве типов массивов. Выглядит это примерно так:

    ОсновнойТип<ТипПараметр>[] array = new ОсновнойТип<ТипПараметр>[длина];

Никакой магии тут нет: технически треугольные скобки являются просто записью имени типа:

    ArrayList<String>[] list = new ArrayList<String>[10];

***Без параметра***

    StringArrayList[] list = new StringArrayList[10];

## Exceptions and Errors


### 1. Что для программы является исключительной ситуацией? Какие способы обработки ошибок в программах вы знаете?

В повседневной жизни иногда возникают ситуации, которые мы не планировали. Например, встаешь утром на работу, ищешь зарядное устройство к телефону — а его нет. Идешь в ванную, чтобы умыться – отключили воду. Сел в машину – не заводится. Но человек в состоянии довольно легко справиться с такими непредвиденными ситуациями. А как с ними справляются Java-программы, постараемся разобраться в этой статье.

***Что такое исключения / exception java?***

В мире программирования возникновение ошибок и непредвиденных ситуаций при выполнении программы называют исключением. В программе исключения могут возникать в результате неправильных действий пользователя, отсутствии необходимого ресурса на диске, или потери соединения с сервером по сети.

Причинами исключений при выполнении программы также могут быть ошибки программирования или неправильное использование API. В отличие от нашего мира, программа должна четко знать, как поступать в такой ситуации. Для этого в Java предусмотрен механизм исключений.

***Кратко о ключевых словах try, catch, finally, throws***

Обработка исключений в Java основана на использовании в программе следующих ключевых слов:

* try – определяет блок кода, в котором может произойти исключение;
* catch – определяет блок кода, в котором происходит обработка исключения;
* finally – определяет блок кода, который является необязательным, но при его наличии выполняется в любом случае независимо от результатов выполнения блока try.


Эти ключевые слова используются для создания в программном коде специальных обрабатывающих конструкций: try{}catch, try{}catch{}finally, try{}finally{}.

* throw – используется для возбуждения исключения;
* throws – используется в сигнатуре методов для предупреждения, о том что метод может выбросить исключение.

Пример использования ключевых слов в Java-программе:

    //метод считывает строку с клавиатуры
    
    public String input() throws MyException {//предупреждаем с помощью throws,
    // что метод может выбросить исключение MyException
    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    String s = null;
    //в блок try заключаем код, в котором может произойти исключение, в данном
    // случае компилятор нам подсказывает, что метод readLine() класса
    // BufferedReader может выбросить исключение ввода/вывода
    try {
    s = reader.readLine();
    // в блок  catch заключаем код по обработке исключения IOException
    } catch (IOException e) {
    System.out.println(e.getMessage());
    // в блоке finally закрываем поток чтения
    } finally {
    // при закрытии потока тоже возможно исключение, например, если он не был открыт, поэтому “оборачиваем” код в блок try
    try {
    reader.close();
    // пишем обработку исключения при закрытии потока чтения
    } catch (IOException e) {
    System.out.println(e.getMessage());
    }
    }
    
        if (s.equals("")) {
    // мы решили, что пустая строка может нарушить в дальнейшем работу нашей программы, например, на результате этого метода нам надо вызывать метод substring(1,2), поэтому мы вынуждены прервать выполнение программы с генерацией своего типа исключения MyException с помощью throw
    throw new MyException("String can not be empty!");
    }
    return s;
    }


### 2. Что такое исключение для Java-программы? Что значит “программа выбросила исключение”? Опишите ситуации, когда исключения выбрасываются виртуальной машиной(автоматически), и когда необходимо их выбрасывать вручную?

Для чего нужен механизм исключений?
Посмотрим на пример из реального мира. Представьте, что на автомобильной дороге есть участок с аварийным мостом с ограниченной грузоподъемностью. Если по нему поедет автомобиль с массой, превышающей грузоподъемность моста, он может разрушиться, и ситуация для водителя может стать, мягко говоря, исключительной.

Чтобы этого не произошло, дорожная служба заблаговременно устанавливает предупредительные знаки на дороге.

Водитель автомобиля, глядя на предупреждающий знак, будет сравнивать массу своего автомобиля с разрешенной для проезда по мосту. Если она превышает ее – он поедет по объездному пути.

Благодаря действиям дорожной службы водители грузового транспорта, во-первых, получили возможность заблаговременно изменять свой путь, во-вторых, предупреждены об опасности на основном пути, и, наконец, предупреждены о невозможности использования моста при определенных условиях.

Возможность предупреждения и разрешения исключительной ситуации в программе для ее продолжения – одна из причин использования исключений в Java. Механизм исключений также позволяет защитить написанный вами код (программный интерфейс) от неправильного использования пользователем за счет валидации (проверки) входящих данных.

Давайте теперь на секунду побудем дорожной службой. Во-первых, вы должны знать места, где автомобилистов могут ждать неприятности. Во-вторых, вам нужно заготовить и установить предупредительные знаки. И, наконец, вам нужно предусмотреть объездные маршруты в случае опасности на основном пути.

В Java механизм исключений работает похожим образом. На стадии разработки программы мы «ограждаем» опасные участки кода в отношении исключений с помощью блока try{}, предусматриваем «запасные» пути с помощью блока catch{}, в блоке finally{} мы пишем код, который выполняется в программе при любом исходе.

В случаях, когда мы не можем  предусмотреть «запасной путь» или намеренно хотим предоставить право его выбора пользователю, мы должны, по крайней мере, предупредить его об опасности. Почему? А вы только вообразите негодование водителя, который доедет до аварийного моста, по которому нельзя проехать, не встретив по дороге ни одного предупреждающего знака!

В программировании при написании своих классов и методов мы не всегда можем предвидеть контекст их использования другими разработчиками в своих программах, поэтому не можем предвидеть на 100% правильный путь для разрешения  исключительной ситуации. В то же время, правило хорошего тона — предупредить пользователей нашего кода о возможности исключительной ситуации.

Механизм исключений Java позволяет нам сделать это с помощью throws – по сути, объявления общего поведения нашего метода, заключающееся в выбрасывании исключения, и предоставляя, таким образом, написание кода по обработке исключения в Java пользователю метода.

Предупреждение о «неприятностях»
Когда вы не планируете обрабатывать исключение в своем методе, но хотите предупредить пользователей метода о возможных исключительных ситуациях — используйте ключевое слово throws. Это ключевое слово в сигнатуре метода означает, что при определенных условиях метод, может выбросить исключение.

Такое предупреждение является частью интерфейса метода и предоставляет право пользователю на собственный вариант реализации обработчика исключения.

После throws мы указываем тип выбрасываемого исключения. Обычно это наследники класса Exception Java. Поскольку Java является объектно-ориентированным языком, все исключения в Java представляют собой объекты.



### 3. Приведите иерархию классов-исключений, делящую исключения на проверяемые и непроверяемые. В чем особенности проверяемых и непроверяемых исключений?

Иерархия исключений Java
При возникновении ошибки в процессе выполнения программы исполняющая среда JVM создает объект нужного типа из иерархии исключений Java – множества возможных исключительных ситуаций, унаследованных от общего «предка» – класса Throwable.

Исключительные ситуации, возникающие в программе, можно разделить на две группы:
Ситуации, при которых восстановление дальнейшей нормальной работы программы невозможно
Восстановление возможно.
К первой группе относят ситуации, когда возникают исключения, унаследованные из класса Error. Это ошибки, возникающие при выполнении программы в результате сбоя работы JVM, переполнения памяти или сбоя системы. Обычно они свидетельствуют о серьезных проблемах, устранить которые программными средствами невозможно. Такой вид исключений в Java относится к неконтролируемым (unchecked) на стадии компиляции.

К этой группе также относят RuntimeException – исключения, наследники класса Exception, генерируемые  JVM во время выполнения программы. Часто причиной возникновения их являются ошибки программирования. Эти исключения также являются неконтролируемыми (unchecked) на стадии компиляции, поэтому написание кода по их обработке не является обязательным.

Ко второй группе относят исключительные ситуации, предвидимые еще на стадии написания программы, и для которых должен быть написан код обработки. Такие исключения являются контролируемыми (checked). Основная часть работы разработчика на Java при работе с исключениями – обработка таких ситуаций.




### 4. Объясните работу оператора try-catch-finally. Когда данный оператор следует использовать? Сколько блоков catch может соответствовать одному блоку try? Можно ли вкладывать блоки try друг в друга, можно ли вложить блок try в catch или finally? Как происходит обработка исключений, выброшенных внутренним блоком try, если среди его блоков catch нет подходящего? Что называют стеком операторов try? Как работает блок try с ресурсами.

Создание блоков кода, для которых мы предусматриваем обработку исключений в Java, производится в программе с помощью конструкций try{}catch, try{}catch{}finally, try{}finally{}.

![Рисунок 6](https://cdn.javarush.ru/images/article/2cb82932-4d46-4565-88a7-73d4d869329b/512.webp")

При возбуждении исключения в блоке try обработчик исключения ищется в следующем за ним блоке catch. Если в catch есть обработчик данного типа исключения – управление переходит к нему. Если нет, то JVM ищет обработчик этого типа исключения в цепочке вызовов методов до тех пор, пока не будет найден подходящий catch.

После выполнения блока catch управление передается в необязательный блок finally.

В случае, если подходящий блок catch не найден, JVM останавливает выполнение программы, и выводит стек вызовов методов – stack trace, выполнив перед этим код блока finally при его наличии.

Пример обработки исключений:

    public class Print {
    
         void print(String s) {
            if (s == null) {
                throw new NullPointerException("Exception: s is null!");
            }
            System.out.println("Inside method print: " + s);
        }
    
        public static void main(String[] args) {
            Print print = new Print();
            List list= Arrays.asList("first step", null, "second step");
    
            for (String s:list) {
                try {
                    print.print(s);
                }
                catch (NullPointerException e) {
                    System.out.println(e.getMessage());
                    System.out.println("Exception was processed. Program continues");
                }
                finally {
                    System.out.println("Inside bloсk finally");
                }
                System.out.println("Go program....");
                System.out.println("-----------------");
            }
    
        }
        }

Результаты работы метода main:

    Inside method print: first step
    Inside bloсk finally
    Go program....
    -----------------
    Exception: s is null!
    Exception was processed. Program continues
    Inside bloсk finally
    Go program....
    -----------------
    Inside method print: second step
    Inside bloсk finally
    Go program....
    -----------------

Блок finally обычно используется для того, чтобы закрыть открытые в блоке try потоки или освободить ресурсы. Однако при написании программы не всегда возможно уследить за закрытием всех ресурсов. Для облегчения нашей жизни разработчики Java предложили нам конструкцию try-with-resources, которая автоматически закрывает ресурсы, открытые в блоке try.

Наш первый пример можно переписать так с помощью try-with-resources:

    public String input() throws MyException {
    String s = null;
    try(BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))){
    s = reader.readLine();
    } catch (IOException e) {
    System.out.println(e.getMessage());
    }
    if (s.equals("")){
    throw new MyException ("String can not be empty!");
    }
    return s;
    }

Благодаря возможностям Java, начиная с версии 7, мы также можем объединять перехват разнотипных исключений в одном блоке, делая код более компактным и читабельным. Например:

    public String input() {
    String s = null;
    try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
    s = reader.readLine();
    if (s.equals("")) {
    throw new MyException("String can not be empty!");
    }
    } catch (IOException | MyException e) {
    System.out.println(e.getMessage());
    }
    return s;
    }

### 5. Укажите правило расположения блоков catch в зависимости от типов перехватываемых исключений. Может ли перехваченной исключение быть сгенерировано снова, и, если да, то как и кто в этом случае будет обрабатывать повторно сгенерированное исключение? Может ли блок catch выбрасывать иные исключения, и если да, то опишите ситуацию, когда это может быть необходимо.

Перехват исключений осуществляется в блоке try/catch. Общий вид:
    
    try{
    
    } catch (Exception e){
    
    }

Первое идет ключевое слово try, далее блок кода (защищенный блок кода) в фигурных скобках (фигурные скобки обязательны). После защищенного блока кода располагается ключевое слово catch (обязательно, если не присутствует блок finally), после которого в скобках указывается тип исключения, которое необходимо обработать, в следующих фигурных скобках, располагается код, который так или иначе обрабатывает сгенерированное исключение. Если выполнение кода в блоке try происходит без каких-либо проблем, то блок catch игнорируется, если же в блоке try возникает исключение, то выполнение кода прекращается и передается блоку catch c соответствующем исключением. Пример:

    public class Example {    
    public static void main(String[] args) {
    System.out.print(" 1 ");
    try{
    System.out.print(" 2 ");
    ex();
    System.out.print(" 3 ");
    } catch (Exception e){
    System.out.print(" 4 ");            
    }
    System.out.print(" 5 ");
    
        }
        
        public static void ex() throws Exception{        
            throw new Exception();        
        }
    
    }

Вывод:
1 2 4 5

Как видите, после того как было сгенерировано исключение в методе ex(), выполнение программы перешло к блоку catch() и код System.out.print(“ 3 “); выполнен не был. После обработки исключения выполнение программы продолжилось в методе main().

Немного о том, что можно сделать не так:

    try
    ex();
    catch (Exception e)
    e.printStackTrace();

В результате компиляции этого кода возникнет ошибка, фигурные скобки для блоков try/catch обязательны!

    try{
    ex();
    }

В этом случае пропущен блок catch, что тоже приведет к ошибке компиляции.

Может и оно будет передано в виртуальную машину Java (JVM).

В Java 7 стала доступна новая конструкция, с помощью которой можно перехватывать несколько исключений одним блоком catch:

    try {  
    ...
    } catch( IOException | SQLException ex ) {  
    logger.log(ex);
    throw ex;
    }

Такая запись допустима, если имеется связка try{} finally {}. Но смысла в такой записи не так много, всё же лучше иметь блок catch в котором будет обрабатываться необходимое исключение.

    String x = "z";
    try {
    x="234";
    } finally {
    x = "Finally";
    }

### 6. Когда происходит вызов блока finally? Существуют ли ситуации, когда блок finally не будет вызван? Может ли блок finally выбрасывать исключений? Может ли блок finally выполнится дважды?

Блок finally.

Общий вид:

    try{
    
    } catch (Exception e){
    
    } finally{
    
    }

Если в методе генерируется исключение оставшиеся в нем операторы не выполняются, тогда возникает следующая проблема – если в методе задействованы локальные ресурсы, то они не высвобождаются. В этом случае на помощь придет блок finally. Принцип его работы очень прост – он выполняется всегда при любых обстоятельствах. Если в блоке try не было сгенрировано никаких исключений, то следом выполняется блок finally, если в блоке try было сгенерировано исключение, то выполняется блок catch, а затем finally. Есть только одно исключение – если перед блоком finally был сделан вызов System.exit(0), то программа завершает свою работу без выполнения блока finally.

Обратите внимание, что последовательность блоков очень важна, нельзя использовать finally перед catch. Небольшой пример:

    public class Example {    
    public static void main(String[] args) {        
    System.out.print(" 1 ");
    try{
    System.out.print(" 2 ");
    ex();
    System.out.print(" 3 ");
    } catch (Exception e){
    System.out.print(" 4 ");            
    } finally{
    System.out.print(" 5 ");
    }
    System.out.print(" 6 ");
    }
    
        public static void ex() throws Exception{        
            throw new Exception();        
        }
    
    }


Вывод:
1 2 4 5 6

Как видно блок finally выполнился сразу за блоком catch, а после передал управление методу main(). Давайте рассмотрим более интересный пример:

    public class Example {    
    public static void main(String[] args) {        
    System.out.print(" 1 ");
    try{
    System.out.print(" 2 ");
    ex();
    System.out.print(" 3 ");
    } finally{
    System.out.print(" 4 ");
    }
    System.out.print(" 5 ");
    }
    
        public static void ex() throws Exception{        
            throw new Exception();        
        }
    
    }

Вывод:
1 2 4

Если Вы заметили в примере отсутствует блок catch. И так во время вызова метода ex() генерируется исключение, которое мы никак не обрабатываем, управление передается блоку finally после выполнения которого, исключение передается обратно вызывающей части программы.

Как вы думаете, что произойдет в результате выполнения этого кода:

    class CustomException extends RuntimeException{}
    
    public class Example{
    public static void main(String[] args) {        
    try{
    throw new RuntimeException();            
    } catch(RuntimeException e){
    throw new RuntimeException();
    } finally{
    throw new CustomException();
    }
    }
    }

В блоке try генерируется исключение, которое обрабатывается блоком catch, который в свою очередь тоже генерирует исключение класса RuntimeException, но как говорилось выше блок finally выполняется всегда. Блок finally генерирует новое исключение класса CustomException, которое скрывает исключение из блока catch. В результате выполнения этого кода получаем:

Exception in thread «main» example.CustomException

Существует небольшая хитрость, которой пользуются многие программисты, она заключается в разделении блоков try/cath и try/finally, что делает код более понятным:

    Inputstream in = ...
    try{
    try{
    ...
    } finally{
    in.close();
    }
    
            } catch(IOException e){
                
            }

В примере внутренний блок try отвечает только за закрытие потока ввода, а внешний блок try сообщает об ошибках. Несомненный плюс подобного подхода в том, что ошибки выявляются и в блоке finally.

