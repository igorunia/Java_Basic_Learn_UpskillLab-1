#Strings
##1.	Как создать объект класса String, какие конструкторы класса String вы знаете? Что такое строковый литерал? Объясните, что значит “упрощенное создание объекта String”?
**Строка** — объект, что представляет последовательность символов. Для создания и манипулирования строками Java платформа предоставляет общедоступный финальный (не может иметь подклассов) класс java.lang.String. Данный класс является неизменяемым (immutable) — созданный объект класса String не может быть изменен. Можно подумать что методы имеют право изменять этот объект, но это неверно. Методы могут только создавать и возвращать новые строки, в которых хранится результат операции. Неизменяемость строк предоставляет ряд возможностей:

-	использование строк в многопоточных средах (String является потокобезопасным (thread-safe) )
-	использование String Pool (это коллекция ссылок на String объекты, используется для оптимизации памяти)
-	использование строк в качестве ключей в HashMap (ключ рекомендуется делать неизменяемым)
###Создание
**Мы можем создать объект класса String несколькими способами:**
-	Используя строковые литералы
-	С помощью конструкторов

**Строковый литерал** — последовательность символов заключенных в двойные кавычки. Важно понимать, что всегда когда вы используете строковой литерал компилятор создает объект со значением этого литерала:
```java
String habr = "habrahabr";
```
**Конструктор** – это специальный метод, который вызывается при создании нового объекта.
Есть конструкторы без параметров, который создает пустую строку, а есть которые создаются из массивов символов.

**Примеры:**
```java
String first = new String(); 
String second = new String(habr);
String habr = "habrahabr"; 
char[] habrAsArrayOfChars = {'h', 'a', 'b', 'r', 'a', 'h', 'a', 'b', 'r'}; 
byte[] habrAsArrayOfBytes = {104, 97, 98, 114, 97, 104, 97, 98, 114};
```
Постоянное строительство новых объектов таким способом может привести к снижению производительности. Их лучше заменить на аналогичные инициализации с помощью строковых литералов.
Конструкторы могут формировать объект строки с помощью массива символов. Происходит копирование массива, для этого используются статические методы copyOf и copyOfRange (копирование всего массива и его части (если указаны 2-й и 3-й параметр конструктора) соответственно) класса Arrays, которые в свою очередь используют платформо-зависимую реализацию System.arraycopy.
Можно также создать объект строки с помощью массива байтов. Дополнительно можно передать параметр класса Charset, что будет отвечать за кодировку. Происходит декодирование массива с помощью указанной кодировки (если не указано — используется Charset.defaultCharset(), который зависит от кодировки операционной системы) и, далее, полученный массив символов копируется в значение объекта.



##2.	Можно ли изменить состояние объекта типа String? Что происходит при попытке изменения состояния объекта типа String? Можно ли наследоваться от класса String? Как вы думаете, почему строковые объекты immutable?
_Нет, так как класс String объявлен как final._
- Строковый пул возможен только потому, что строка неизменна в Java, таким образом виртуальная машина сохраняет много места в памяти (heap space), поскольку разные строковые переменные указывают на одну переменную в пуле. Если бы строка не была неизмененяемой, тогда бы интернирование строк не было бы возможным, потому что если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.
- Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть изменено, в противном случае любой хакер может изменить значение ссылки и вызвать проблемы в безопасности приложения.
- Так как строка неизменная, она безопасна для много поточности и один экземпляр строки может быть совместно использован различными нитями. Это позволяет избежать синхронизации для потокобезопасности, строки полностью потокобезопасны.
- Строки используются в Java classloader и неизменность обеспечивает правильность загрузки класса при помощи Classloader. К примеру, задумайтесь об экземпляре класса, когда вы пытаетесь загрузить java.sql.Connection класс, но значение ссылки изменено на myhacked.Connection класс, который может осуществить нежелательные вещи с вашей базой данных.
- Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Это причина, почему строка наиболее часто используемый объект, используемый в качестве ключа HashMap.

В java есть ключевое слово – **final**. Оно может применяться к классам, методам, переменным (в том числе аргументам методов). Для класса это означает, что класс не сможет иметь подклассов, т.е. запрещено наследование. Это полезно при создании immutable (неизменяемых) объектов, например, класс String объявлен, как final. Следует также отметить, что к абстрактным классам (с ключевым словом abstract), нельзя применить модификатор final, т.к. это взаимоисключающие понятия. Для метода final означает, что он не может быть переопределен в подклассах. Это полезно, когда мы хотим, чтобы исходную реализацию нельзя было переопределить. Для переменных примитивного типа это означает, что однажды присвоенное значение не может быть изменено. Для ссылочных переменных это означает, что после присвоения объекта, нельзя изменить ссылку на данный объект. Это важно! Ссылку изменить нельзя, но состояние объекта изменять можно.
**Immutable объект** - это объект, состояние которого после создания невозможно изменить. В случае Java это значит что все поля экземпляра у класс отмечены как final и являются примитивами или тоже immutable типами.

##3.	Объясните, что такое кодировка? Какие кодировки вы знаете? Как создать строки в различной кодировке?
На самом глубоком уровне компьютер оперирует исключительно цифрами 0 и 1. Это так называемый двоичный код, а единички и нули называются битами, от «binary digit» — «двоичная цифра».
Обычные, привычные нам числа в десятичной системе счисления, закодированы с помощью двоичных чисел:
-	0 ← 0
-	1 ← 1
-	2 ← 10
-	3 ← 11
-	4 ← 100
-	5 ← 101

Но как быть с текстом? Компьютер на самом деле не знает ничего о буквах, знаках пунктуации и прочих текстовых символах. Все эти символы так же закодированы числами.
Можно взять английский алфавит и дать каждой букве число, начиная с единицы по порядку:
-	a ← 1
-	b ← 2
-	c ← 3
-	d ← 4
-	...
-	z ← 26

Далее можно научить компьютер понимать эту таблицу и переводить текст в числа и наоборот — числа в текст:
-	hello → 8 5 12 12 15
-	7 15 15 4 → good

В этом заключается суть кодировок.

**Виды кодировок:**
- **Юникод** — это стандарт кодирования символов для большинства языков мира, включая вымершие, а также много различных вспомогательных символов (например, математических). Юникод разрабатывает одноименный консорциум (www.unicode.org).
У каждого символа есть официальное именование (например, «latin small letter a») и код (code point) — число от 0 до 10FFFF.
- **Символ** (Character) — наименьший компонент письменного языка, который имеет семантическое значение. Еще одно значение символа — абстрактный символ — единица информации, используемая для управления, организации и для представления текстовой информации.
- **Глиф** — графическое представление символа. Некоторые символы могут иметь различное начертание, например в зависимости от позиции в слове. Но это уже проблемы системы вывода на экран. Сборище глифов, обычно одного стиля, называют шрифтом
- **Character set** — Набор элементов для представления текстовой информации. Т.е. это просто набор любых символов, например строчные буквы английского алфавита.
- **Coded character set** — character set, у которого каждому элементу присвоен числовой код (code point).
С charset немного сложнее — юникод определяет его просто как синоним coded character set (www.unicode.org/...x.html#charset, а в java это означает encoding — правило отображения кодов символов (code points) в кодовые единицы (code units).
ode point (кодовая точка)- любое значение в пространстве кодов юникода, т.е. сами коды символов.

- **Code unit** (кодовая единица)- битовые последовательности, с помощью которых можно закодировать code point. В юникод используют 3 типа code unit — 8ми битовые (byte), 16ти битовые и 32х битовые.

В большинстве языков программирования (включая java) для внутреннего представления (класс String) используют 16 битные code units, т.е UTF-16. Поэтому, когда вы у строки вызываете метод length, вы получите длину в кодовых единицах, а не количество символов в строке.

- UTF — Unicode Transformation format — способ кодирования кодов символов в последовательности байт.

Есть формы кодирования UTF, а есть схемы. И вообще говоря это не одно и то же.
Формы кодирования — правила разложения кода символа в кодовые единицы (code units). А схема кодирования — правила сериализации кодовых единиц в байты (например, при записи на диск).
Есть 3 формы кодирования — UTF-8, UTF-16, UTF-32.
В UTF-32 каждый код символа кодируется 4мя байтами, т.е. это кодирование с фиксированной длиной (fixed length encoding).
В UTF-8 каждый символ юникода кодируется последовательностью от одного до 4х байт по хитрой схеме (en.wikipedia.org/...-8#Description, т.е. это variable length encoding.
Преимущества данного метода в том, что коды ascii (кодировка, придуманная американцами, соответствуе первым 127 символам в наборе unicode) кодируются без изменений, одним байтом.
В UTF-16 для кодирования кодов символов с номерами больше U+FFFF (их называют supplementary characters) используют суррогатные пары — коды из диапазона U+D800-U+DFFF. Т.е., символы с кодами больше U+10000 кодируются двумя 16ти битными парами. Коды из диапазона суррогатых пар не должны встречаться поодиночке. Пространство кодов с кодами U+0000 — U+FFFF называют Basic Multilingual Plane (BMP).
Схем кодирования семь — UTF-8, UTF-16, UTF-16BE, UTF-16LE, UTF-32, UTF-32BE, UTF-32LE.
BE и LE означают big endian или little endian, т.е. в каком порядке идут байты, сначала старшие или сначала младшие. Если не указано и нет BOM, то следует трактовать как BE.
BOM — byte order mark — отметка порядка байтов. Символ с кодом FEFF (неразрывный непечатный пробел) записывают в начале текста. При вычитке проверяют первый байт, если это BOM и код FFFE, значит порядок little endian. Если код FEFF или это не BOM, то порядок big endian.


##4.	Что такое пул литералов? Как строки заносятся в пул литералов? Как занести строку в пул литералов и как получить ссылку на строку, хранящуюся в пуле литералов? Где хранится(в каком типе памяти) пул литералов в Java 1.6 и Java 1.7?
Как подсказывает название, **пул строк** – это набор строк, который хранится в памяти Java heap. Мы знаем, что String это специальный класс в Java, и мы можем создавать объекты этого класса, используя оператор new точно так же, как и создавать объекты, предоставляя значение строки в двойных кавычках.
Пул строк возможен исключительно благодаря неизменяемости строк в Java и реализации идеи интернирования строк. Пул строк также является примером паттерна Приспособленец (Flyweight). Пул строк помогает экономить большой объем памяти, но с другой стороны создание строки занимает больше времени. Когда мы используем двойные кавычки для создания строки, сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка. Тем не менее, когда мы используем оператор new, мы принуждаем класс String создать новый объект строки, а затем мы можем использовать метод intern() для того, чтобы поместить строку в пул, или получить из пула ссылку на другой объектString с таким же значением. Ниже приведен пример, показывающий работу пула строк.
```java
public class StringPool {
    public static void main(String[] args) {
        String s1 = "Cat";
        String s2 = "Cat";
        String s3 = new String("Cat");

        System.out.println("s1 == s2 :"+(s1==s2));
        System.out.println("s1 == s3 :"+(s1==s3));
    }
}
```
##5.	В чем отличие объектов классов StringBuilder и StringBuffer от объектов класса String? Какой из этих классов потокобезопасный? Как необходимо сравнивать на равенство объекты классов StringBuilder и StringBuffer и почему?
Строка является неизменной и финализированной в Java, поэтому все наши манипуляции со строкой всегда будут создавать новую строку. Манипуляции со строками ресурсоемкие, поэтому Java обеспечивает два полезных класса для манипуляций со строками – StringBuffer и StringBuilder. StringBuffer и StringBuilder являются изменяемыми классами. Операции с StringBuffer потокобезопасны и синхронизированы, а методы StringBuilder не потокобезопасны. Поэтому когда несколько нитей работают с одной строкой, мы должны использовать StringBuffer, но в однопоточном окужении мы должны использовать StringBuilder. StringBuilder более производительный, чем StringBuffer, поскольку не обременен синронизацией.
Строки являются неизменными, поэтому мы не можем изменить их значение в программе. Следовательно они потокобезопасные и могут благополучно использоваться в мультипоточном окружении.

Есть два способа проверить, являются ли две строки эквивалентными – используя оператор “==”, или используя метод equals. Когда мы используем оператор “==”, он проверяет значение строки, как ссылки, но в программировании большую часть времени мы проверяем эквивалентность строки только для значения. Поэтому мы должны использовать метод equals для проверки двух строк на эквивалентность. Еще есть метод equalsIgnoreCase, который мы можем использовать для игнорирования регистра.
```java
String s1 = "abc";
String s2 = "abc";
String s3= new String("abc");
System.out.println("s1 == s2 ? "+(s1==s2)); //true
System.out.println("s1 == s3 ? "+(s1==s3)); //false
System.out.println("s1 equals s3 ? "+(s1.equals(s3))); //true
```

##6.	Что такое Unicode?
**Юнико́д** (чаще всего) или Унико́д (англ. Unicode) — стандарт кодирования символов, включающий в себя знаки почти всех письменных языков мира. В настоящее время стандарт является преобладающим в Интернете. Стандарт предложен в 1991 году некоммерческой организацией «Консорциум Юникода»

##7.	Какие методы класса String используются для работы с кодовыми точками? Как вы думаете, когда следует их использовать?
**Метод (ы)	Описание**

toChars(int codePoint, char[] dst, int dstIndex)
toChars(int codePoint)
Преобразовывает указанную кодовую точку Unicode в ее представление UTF-16 и помещает это в a char массив. Демонстрационное использование: Character.toChars(0x10400)

toCodePoint(char high, char low)
toCodePoint(CharSequence, int)
toCodePoint(char[], int, int)
Преобразовывает указанные параметры в его дополнительное значение кодовой точки. Различные методы принимают различные входные форматы.

codePointAt(char[] a, int index)
codePointAt(char[] a, int index, int limit)
codePointAt(CharSequence seq, int index)
Возвращается кодовая точка Unicode в указанном индексируют. Третий метод берет a CharSequence и второй метод осуществляет верхний предел индексирования.

codePointBefore(char[] a, int index)
codePointBefore(char[] a, int index, int start)
codePointBefore(CharSequence seq, int index)
codePointBefore(char[], int, int)
Возвращает кодовую точку Unicode прежде, чем указанные индексируют. Третий метод принимает a CharSequence и другие методы принимают a char массив. Второй метод осуществляет более низкий предел на индексировании.

charCount(int codePoint)
Возвращает значение 1 для символов, которые могут быть представлены синглом char. Возвращает значение 2 для дополнительных символов, которые требуют два chars.

 
#Regular Expressions
##1.	Расскажите, что представляет собой регулярное выражение? Что такое метасимволы регулярного выражения? Какие вы знаете классы символов регулярных выражений? Что такое квантификаторы? Какие логические 
**Регулярное выражение (RegEx)** – это шаблон для поиска строки в тексте. В Java исходным представлением этого шаблона всегда является строка, то есть объект класса String. Однако не любая строка может быть скомпилирована в регулярное выражение, а только та, которая соответствует правилам написания регулярного выражения – синтаксису, определенному в спецификации языка. Для написания регулярного выражения используются буквенные и цифровые символы, а также метасимволы – символы, имеющие специальное значение в синтаксисе регулярных выражений. Например:
```java
String regex=”java”; // шаблон строки ”java”;
String regex=”\\d{3}”; // шаблон строки из трех цифровых символов;
```
###Создание регулярных выражений в Java
**Чтобы создать RegEx в Java, нужно сделать два простых шага:** 
-	написать его в виде строки с учётом синтаксиса регулярных выражений;
-	скомпилировать эту строку в регулярное выражение;
Работа с регулярными выражениями в любой Java-программе начинается с создания объекта класса Pattern. Для этого необходимо вызвать один из двух имеющихся в классе статических методов compile. Первый метод принимает один аргумент – строковый литерал регулярного выражения, а второй – плюс еще параметр, включающий режим сравнения шаблона с текстом:
```java
public static Pattern compile (String literal)
public static Pattern compile (String literal, int flags)
```
Список возможных значений параметра flags определен в классе Pattern и доступен нам как статические переменные класса. Например:
операторы регулярных выражений вы знаете? Что значит “якорь” для регулярного выражения?
Pattern pattern = Pattern.compile("java", Pattern.CASE_INSENSITIVE);//поиск совпадений с шаблоном будет производиться без учета регистра символов.
По сути, класс **Pattern** — это конструктор регулярных выражений. Под «капотом» метод compile вызывает закрытый конструктор класса Pattern для создания скомпилированного представления. Такой способ создания экземпляра шаблона реализован с целью создания его в виде неизменяемого объекта. При создании производится синтаксическая проверка регулярного выражения. При наличии ошибок в строке – генерируется исключение PatternSyntaxException.
**Синтаксис регулярных выражений**
Синтаксис регулярных выражений основан на использовании символов <([{\^-=$!|]})?*+.>, которые можно комбинировать с буквенными символами. В зависимости от роли их можно разделить на несколько групп:
**Метасимволы для поиска совпадений границ строк или текста**

^	 начало строки

$	конец строки

\b	граница слова

\B	не граница слова

\A	начало ввода

\G	конец предыдущего совпадения

\Z	конец ввода

\z	конец ввода

**Метасимволы для поиска символьных классов**


\d	цифровой символ

\D	нецифровой символ

\s	символ пробела

\S	непробельный символ

\w	буквенно-цифровой символ или знак подчёркивания

\W	любой символ, кроме буквенного, цифрового или знака подчёркивания

.	любой символ

**Метасимволы для поиска символов редактирования текста**


\t	символ табуляции

\n	символ новой строки

\r	символ возврата каретки

\f	переход на новую страницу

\u 0085	символ следующей строки

\u 2028	символ разделения строк

\u 2029	символ разделения абзацев

**Метасимволы для группировки символов**


[абв]	любой из перечисленных (а,б, или в)

[^абв]	любой, кроме перечисленных (не а,б, в)

[a-zA-Z]	слияние диапазонов (латинские символы от a до z без учета регистра )

[a-d[m-p]]	объединение символов (от a до d и от m до p)

[a-z&&[def]]	пересечение символов (символы d,e,f)

[a-z&&[^bc]]	вычитание символов (символы a, d-z)

Метасимволы для обозначения количества символов – квантификаторы. Квантификатор всегда следует после символа или группы символов.

?	один или отсутствует

*	ноль или более раз

+	один или более раз

{n}	n раз

{n,}	n раз и более

{n,m}	не менее n раз и не более m раз

#Жадный режим квантификатора

Особенностью квантификаторов является возможность использования их в разных режимах: жадном, сверхжадном и ленивом. Сверхжадный режим включается добавлением символа «+» после квантификатора, а ленивый – символа «?». Например:
```java
"А.+а" // жадный режим
"А.++а" // сверхжадный режим
"А.+?а" // ленивый режим
```
Попробуем на примере этого шаблона разобраться в работе квантификаторов в различных режимах. По умолчанию квантификатор работает в жадном режиме. Это означает, что он ищет максимально длинное совпадение в строке. В результате выполнения этого кода:
```java
public static void main(String[] args) {
    String text = "Егор Алла Александр";
    Pattern pattern = Pattern.compile("А.+а");
    Matcher matcher = pattern.matcher(text);
    while (matcher.find()) {
        System.out.println(text.substring(matcher.start(), matcher.end()));
    }
}
```
мы получим такой вывод: Алла Алекса Алгоритм поиска по заданному шаблону "А.+а", выполняется в следующей последовательности: 

1.	В заданном шаблоне первый символ – это русский символ буквы А. Matcher сопоставляет его с каждым символом текста, начиная с нулевой позиции. На нулевой позиции в нашем тексте находиться символ Е, поэтому Matcher перебирает последовательно символы в тексте, пока не встретит совпадение с шаблоном. В нашем примере это символ на позиции №5.
https://cdn.javarush.ru/images/article/025a11b5-cffb-4158-9838-a50ff1659893/800.webp

После того, как найдено совпадение с первым символом шаблона, Matcher сверяет соответствие со вторым символом шаблона. В нашем случае это символ «.», который обозначает любой символ.

https://cdn.javarush.ru/images/article/d5995c0d-e88a-4627-845e-6cd3081289e0/800.webp

Matcher переходит к проверке следующего символа из шаблона. В нашем шаблоне он задан с помощью квантификатора «.+». Поскольку количество повторений «любого символа» в шаблоне – один и более раз, Matcher берет по очереди следующий символ из строки и проверяет его на соответствие шаблону, до тех пор, пока будет выполняться условие «любой символ», в нашем примере – до конца строки (с поз. №7 -№18 текста

https://cdn.javarush.ru/images/article/2880ac59-56a2-42c9-b6d3-285241d3e3db/800.webp

- По сути, Matcher, захватывает все строку до конца – в этом как раз и проявляется его «жадность».

- После того как Matcher дошел до конца текста и закончил проверку для части шаблона «А.+», Matcher начинает проверку для оставшейся части шаблона – символ буквы а. Так как текст в прямом направлении закончился, проверка происходит в обратном направлении, начиная с последнего символа:

https://cdn.javarush.ru/images/article/4edc0442-3476-4827-8b0a-f60944f030c9/800.webp

Matcher «помнит» количество повторений в шаблоне «.+» при котором он дошел до конца текста, поэтому он уменьшает количество повторений на единицу и проверяет соответствие шаблона тексту, до тех пор пока не будет найдено совпадение:

https://cdn.javarush.ru/images/article/f7c55fca-83fb-4292-9485-fe9aa7449f50/800.webp

**Сверхжадный режим квантификатора**
В сверхжадном режиме работа матчера аналогична механизму жадного режима. Отличие состоит в том, что при захватывании текста до конца строки поиск в обратном направлении не происходит. То есть первые три этапа при сверхжадном режиме будут аналогичны жадному режиму. После захвата всей строки матчер добавляет остаток шаблона и сравнивает с захваченной строкой. В нашем примере при выполнении метода main с шаблоном "А.++а" совпадений не будет найдено.

https://cdn.javarush.ru/images/article/43a0e49c-8e25-470c-bd80-1396334cb9a4/800.webp

**Ленивый режим квантификатора**

1.	В этом режиме на начальном этапе, как и в жадном режиме, ищется совпадение с первым символом шаблона:

https://cdn.javarush.ru/images/article/2e7f79db-6eba-464e-a3d0-f988ad46bd40/800.webp

Далее ищется совпадение со следующим символом шаблона – любым символом:

https://cdn.javarush.ru/images/article/e3046c84-473b-44d4-9873-a87e6fcb6a35/800.webp

В отличие от жадного режима, в ленивом ищется самое короткое совпадение в тексте, поэтому после нахождения совпадения со вторым символом шаблона, который задан точкой и соответствует символу на позиции №6 текста, Matcher будет проверять соответствие текста остатку шаблона – символу «а»

https://cdn.javarush.ru/images/article/b24fe49e-ab84-4884-be09-f0599628a10b/800.webp

Поскольку совпадение с шаблоном в тексте не найдено (на позиции №7 в тексте находится символ «л»), Matcher добавляет еще один «любой символ» в шаблоне, так как он задан как один и более раз, и опять сравнивает шаблон с текстом на позициях с №5 по №8:

https://cdn.javarush.ru/images/article/13543dd7-56bd-46d9-b466-d6e955b811e3/800.webp

В нашем случае найдено совпадение, но конец текста ещё не достигнут. Поэтому с позиции №9 проверка начинается с поиска первого символа шаблона по аналогичному алгоритму и далее повторяется вплоть до окончания текста.

https://cdn.javarush.ru/images/article/d77ca7c4-9281-4750-9199-800aff1130b0/800.webp

В результате работы метода main при использовании шаблона "А.+?а" мы получим следующий результат: Алла Алекса Как видно из нашего примера, при использовании разных режимов квантификатора для одного и того же шаблона мы получили разные результаты. Поэтому необходимо учитывать эту особенность и выбирать нужный режим в зависимости от желаемого результата при поиске.

##2.	Какие java-классы работают с регулярными выражениями? В каком пакете они расположены? Приведите пример анализа текста с помощью регулярного выражения и поясните код примера.
**Экранирование символов в регулярных выражениях**

Поскольку регулярное выражение в Java, а точнее — его исходное представление задается с помощью строкового литерала, необходимо учитывать те правила спецификации Java, которые касаются строковых литералов. В частности, символ обратной косой черты «\» в строковых литералах в исходном коде Java интерпретируется как символ управляющей последовательности, который предупреждает компилятор, что следующий за ним символ — специальный и что его нужно особым образом интерпретировать. Например:
```java
String s=“The root directory is \nWindows”;//перенос Windows на новую строку
String s=“The root directory is \u00A7Windows”;//вставка символа параграфа перед Windows
```
Поэтому в строковых литералах, которые описывают регулярное выражение, и используют символ «\» (например, для метасимволов) его нужно удваивать, чтобы компилятор байт-кода Java не интерпретировал его по-своему. Например:
```java
String regex=”\\s”; // шаблон для поиска символов пробела
String regex=”\\”Windows\\””; // шаблон для поиска строки ”Windows”
```
Двойной символ обратной косой черты также следует использовать для экранирования символов, задействованных в качестве специальных, если мы планируем их использовать как «обычные» символы. Например:
```java
String regex=”How\\?”; // шаблон для поиска строки “How?”
```
**Методы класса Pattern**

В классе Pattern есть и другие методы для работы с регулярными выражениями: String pattern() – возвращает исходное строковое представление регулярного выражения, из которого был создан объект Pattern:
```java
Pattern pattern = Pattern.compile("abc");
System.out.println(Pattern.pattern())//"abc"
static boolean matches(String regex, CharSequence input) – позволяет проверить регулярное выражение, переданное в параметре regex на соответствие тексту, переданному в параметре input. Возвращает: true – если текст соответствует шаблону; false – в противном случае; Пример:
System.out.println(Pattern.matches("А.+а","Алла"));//true
System.out.println(Pattern.matches("А.+а","Егор Алла Александр"));//false
int flags() – возвращает значения параметра flags шаблона, которые были установлены при его создании, или 0, если этот параметр не был установлен. Пример:
Pattern pattern = Pattern.compile("abc");
System.out.println(pattern.flags());// 0
Pattern pattern = Pattern.compile("abc",Pattern.CASE_INSENSITIVE);
System.out.println(pattern.flags());// 2
String[] split(CharSequence text, int limit) – разбивает текст, переданный в качестве параметра на массив элементов String. Параметр limit определяет предельное количество совпадений, которое ищется в тексте: 
```
-	при limit>0 – выполняется поиск limit-1 совпадений;
-	при limit<0 – выполняется поиск всех совпадений в тексте
-	при limit=0 – выполняется поиск всех совпадений в тексте, при этом пустые строки в конце массива отбрасываются;

**Пример:**
```java
public static void main(String[] args) {
    String text = "Егор Алла Анна";
    Pattern pattern = Pattern.compile("\\s");
    String[] strings = pattern.split(text,2);
    for (String s : strings) {
        System.out.println(s);
    }
    System.out.println("---------");
    String[] strings1 = pattern.split(text);
    for (String s : strings1) {
        System.out.println(s);
    }
}
```
Вывод на консоль: Егор Алла Анна -------- Егор Алла Анна

**Методы класса Matcher**

Matcher представляет собой класс, из которого создается объект для поиска совпадений по шаблону. Matcher – это «поисковик», «движок» регулярных выражений. Для поиска ему надо дать две вещи: шаблон поиска и «адрес», по которому искать. Для создания объекта Matcher предусмотрен следующий метод в классе Pattern: рublic Matcher matcher(CharSequence input) В качестве аргумента метод принимает последовательность символов, в котором будет производиться поиск. Это объекты классов, реализующих интерфейс CharSequence. в качестве аргумента можно передать не только String, но и StringBuffer, StringBuilder, Segment и CharBuffer. Шаблоном для поиска является объект класса Pattern, на котором вызывается метод matcher. Пример создания матчера:
Pattern p = Pattern.compile("a*b");// скомпилировали регулярное выражение в представление
Matcher m = p.matcher("aaaaab");//создали поисковик в тексте “aaaaab” по шаблону "a*b"
Теперь с помощью нашего «поисковика» мы можем искать совпадения, узнавать позицию совпадения в тексте, заменять текст с помощью методов класса. Метод boolean find() ищет очередное совпадение в тексте с шаблоном. С помощью этого метода и оператора цикла можно производить анализ всего текста по событийной модели (осуществлять необходимые операции при наступлении события – нахождении совпадения в тексте). Например, с помощью методов этого класса int start() и int end() можно определять позиции совпадения в тексте, а с помощью методов String replaceFirst(String replacement) и String replaceAll(String replacement) заменять в тексте совпадения на другой текст replacement. Пример:

```java
public static void main(String[] args) {
    String text = "Егор Алла Анна";
    Pattern pattern = Pattern.compile("А.+?а");
    Matcher matcher = pattern.matcher(text);
    while (matcher.find()) {
        int start=matcher.start();
        int end=matcher.end();
        System.out.println("Найдено совпадение " + text.substring(start,end) + " с "+ start + " по " + (end-1) + " позицию");
    }
    System.out.println(matcher.replaceFirst("Ира"));
    System.out.println(matcher.replaceAll("Ольга"));
    System.out.println(text);
}
```
Вывод программы: Найдено совпадение Алла с 5 по 8 позицию Найдено совпадение Анна с 10 по 13 позицию Егор Ира Анна Егор Ольга Ольга Егор Алла Анна Из примера видно, что методы replaceFirst и replaceAll создают новый объект String – строку, представляющую собой исходный текст, в котором совпадения с шаблоном заменены на текст, переданный методу в качестве аргумента. Причём метод replaceFirst заменяет только первое совпадение, а replaceAll – все совпадения в тесте. Исходный текст остается без изменений. Использование других методов класса Matcher, а также примеры регулярных выражений можно посмотреть в этом цикле статей. Наиболее частые операции с регулярными выражениями при работе с текстом из классов Pattern и Matcher встроены в класс String. Это такие методы как split, matches, replaceFirst, replaceAll. Но на самом деле «под капотом» они используют классы Pattern и Matcher. Поэтому, если вам нужно заменить текст или сравнить строки в программе без написания лишнего кода, используйте методы класса String. Если же вам нужны расширенные возможности – вспомните о классах Pattern и Matcher.

##3.	Что такое группы в регулярных выражениях? Как нумеруются группы? Что представляет собой группа номер 0(ноль)? Приведите пример с использованием групп регулярного выражения.

**Скобочные группы**
Часть шаблона можно заключить в скобки (...). Это называется «скобочная группа».
У такого выделения есть два эффекта:
- Позволяет поместить часть совпадения в отдельный массив.
-	Если установить квантификатор после скобок, то он будет применяться ко всему содержимому скобки, а не к одному символу.
**Примеры**
Разберём скобки на примерах.

**Пример:** gogogo

Без скобок шаблон go+ означает символ g и идущий после него символ o, который повторяется один или более раз. Например, goooo или gooooooooo.
Скобки группируют символы вместе. Так что (go)+ означает go, gogo, gogogo и т.п.
Содержимое скобок в match
Скобочные группы нумеруются слева направо. Поисковый движок запоминает содержимое, которое соответствует каждой скобочной группе, и позволяет получить его в результате.

Метод str.match(regexp), если у регулярного выражения regexp нет флага g, ищет первое совпадение и возвращает его в виде массива:

1.	На позиции 0 будет всё совпадение целиком.
2.	На позиции 1 – содержимое первой скобочной группы.
3.	На позиции 2 – содержимое второй скобочной группы.
           


